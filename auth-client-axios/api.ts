/* tslint:disable */
/* eslint-disable */
/**
 * Auth Service
 * 提供身份管理服务以及OAuth2授权服务。身份管理服务包含用户管理、角色管理、权限管理等，OAuth2授权服务包含应用管理、应用授权模式与授权作用域管理等。
 *
 * The version of the OpenAPI document: v1
 * Contact: hansin@dustlight.cn
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Authority
 */
export interface Authority {
    /**
     * 
     * @type {number}
     * @memberof Authority
     */
    aid?: number;
    /**
     * 
     * @type {string}
     * @memberof Authority
     */
    authorityName?: string;
    /**
     * 
     * @type {string}
     * @memberof Authority
     */
    authorityDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof Authority
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Authority
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface AuthorizationClient
 */
export interface AuthorizationClient {
    /**
     * 
     * @type {string}
     * @memberof AuthorizationClient
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationClient
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationClient
     */
    logo?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AuthorizationClient
     */
    additionalInformation?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof AuthorizationClient
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationClient
     */
    updatedAt?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthorizationClient
     */
    status?: number;
    /**
     * 
     * @type {number}
     * @memberof AuthorizationClient
     */
    uid?: number;
    /**
     * 
     * @type {Array<Resource>}
     * @memberof AuthorizationClient
     */
    resources?: Array<Resource>;
    /**
     * 
     * @type {Array<AuthorizationClientScope>}
     * @memberof AuthorizationClient
     */
    scopes?: Array<AuthorizationClientScope>;
    /**
     * 
     * @type {Array<GrantType>}
     * @memberof AuthorizationClient
     */
    types?: Array<GrantType>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AuthorizationClient
     */
    authorities?: Array<string>;
    /**
     * 
     * @type {Set<string>}
     * @memberof AuthorizationClient
     */
    registeredRedirectUri?: Set<string>;
    /**
     * 
     * @type {number}
     * @memberof AuthorizationClient
     */
    accessTokenValiditySeconds?: number;
    /**
     * 
     * @type {number}
     * @memberof AuthorizationClient
     */
    refreshTokenValiditySeconds?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationClient
     */
    clientSecret?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationClient
     */
    cid?: string;
}
/**
 * 
 * @export
 * @interface AuthorizationClientScope
 */
export interface AuthorizationClientScope {
    /**
     * 
     * @type {number}
     * @memberof AuthorizationClientScope
     */
    sid?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationClientScope
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationClientScope
     */
    subtitle?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationClientScope
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AuthorizationClientScope
     */
    approved?: boolean;
}
/**
 * 
 * @export
 * @interface AuthorizationResponse
 */
export interface AuthorizationResponse {
    /**
     * 
     * @type {AuthorizationClient}
     * @memberof AuthorizationResponse
     */
    client?: AuthorizationClient;
    /**
     * 
     * @type {PublicUser}
     * @memberof AuthorizationResponse
     */
    owner?: PublicUser;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationResponse
     */
    redirect?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthorizationResponse
     */
    count?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AuthorizationResponse
     */
    approved?: boolean;
}
/**
 * 
 * @export
 * @interface Client
 */
export interface Client {
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof Client
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    logo?: string;
    /**
     * 
     * @type {Array<ClientScope>}
     * @memberof Client
     */
    scopes?: Array<ClientScope>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Client
     */
    authorities?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Client
     */
    uid?: number;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    updatedAt?: string;
    /**
     * 
     * @type {Set<string>}
     * @memberof Client
     */
    redirectUri?: Set<string>;
    /**
     * 
     * @type {Set<string>}
     * @memberof Client
     */
    grantTypes?: Set<string>;
    /**
     * 
     * @type {number}
     * @memberof Client
     */
    accessTokenValidity?: number;
    /**
     * 
     * @type {number}
     * @memberof Client
     */
    refreshTokenValidity?: number;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    cid?: string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    secret?: string;
    /**
     * 
     * @type {Set<string>}
     * @memberof Client
     */
    resources?: Set<string>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof Client
     */
    extra?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface ClientScope
 */
export interface ClientScope {
    /**
     * 
     * @type {boolean}
     * @memberof ClientScope
     */
    autoApprove?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClientScope
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientScope
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientScope
     */
    subtitle?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientScope
     */
    sid?: number;
}
/**
 * 
 * @export
 * @interface GrantType
 */
export interface GrantType {
    /**
     * 
     * @type {number}
     * @memberof GrantType
     */
    tid?: number;
    /**
     * 
     * @type {string}
     * @memberof GrantType
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GrantType
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof GrantType
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof GrantType
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface OAuth2AccessToken
 */
export interface OAuth2AccessToken {
    /**
     * 
     * @type {string}
     * @memberof OAuth2AccessToken
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2AccessToken
     */
    expiration?: string;
    /**
     * 
     * @type {Set<string>}
     * @memberof OAuth2AccessToken
     */
    scope?: Set<string>;
    /**
     * 
     * @type {string}
     * @memberof OAuth2AccessToken
     */
    tokenType?: string;
    /**
     * 
     * @type {OAuth2RefreshToken}
     * @memberof OAuth2AccessToken
     */
    refreshToken?: OAuth2RefreshToken;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof OAuth2AccessToken
     */
    additionalInformation?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof OAuth2AccessToken
     */
    expired?: boolean;
    /**
     * 
     * @type {number}
     * @memberof OAuth2AccessToken
     */
    expiresIn?: number;
}
/**
 * 
 * @export
 * @interface OAuth2RefreshToken
 */
export interface OAuth2RefreshToken {
    /**
     * 
     * @type {string}
     * @memberof OAuth2RefreshToken
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface PublicUser
 */
export interface PublicUser {
    /**
     * 
     * @type {number}
     * @memberof PublicUser
     */
    uid?: number;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    unlockedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    avatar?: string;
    /**
     * 
     * @type {number}
     * @memberof PublicUser
     */
    gender?: number;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    nickname?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PublicUser
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    username?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PublicUser
     */
    accountNonExpired?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PublicUser
     */
    accountNonLocked?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PublicUser
     */
    credentialsNonExpired?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    createdAt?: string;
}
/**
 * 
 * @export
 * @interface QueryResultsClient
 */
export interface QueryResultsClient {
    /**
     * 
     * @type {number}
     * @memberof QueryResultsClient
     */
    count?: number;
    /**
     * 
     * @type {Array<Client>}
     * @memberof QueryResultsClient
     */
    data?: Array<Client>;
}
/**
 * 
 * @export
 * @interface QueryResultsUser
 */
export interface QueryResultsUser {
    /**
     * 
     * @type {number}
     * @memberof QueryResultsUser
     */
    count?: number;
    /**
     * 
     * @type {Array<User>}
     * @memberof QueryResultsUser
     */
    data?: Array<User>;
}
/**
 * 
 * @export
 * @interface Resource
 */
export interface Resource {
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    rid?: string;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {number}
     * @memberof Role
     */
    rid?: number;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    roleName?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    roleDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface Scope
 */
export interface Scope {
    /**
     * 
     * @type {number}
     * @memberof Scope
     */
    sid?: number;
    /**
     * 
     * @type {string}
     * @memberof Scope
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Scope
     */
    subtitle?: string;
    /**
     * 
     * @type {string}
     * @memberof Scope
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Scope
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Scope
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    authorities?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    uid?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    unlockedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    avatar?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    gender?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    nickname?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    accountExpiredAt?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    credentialsExpiredAt?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    username?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    accountNonExpired?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    accountNonLocked?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    credentialsNonExpired?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    updatedAt?: string;
    /**
     * 
     * @type {Array<UserRole>}
     * @memberof User
     */
    roles?: Array<UserRole>;
}
/**
 * 
 * @export
 * @interface UserRole
 */
export interface UserRole {
    /**
     * 
     * @type {number}
     * @memberof UserRole
     */
    rid?: number;
    /**
     * 
     * @type {string}
     * @memberof UserRole
     */
    roleName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRole
     */
    roleDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRole
     */
    expiredAt?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserRole
     */
    expired?: boolean;
}

/**
 * AuthoritiesApi - axios parameter creator
 * @export
 */
export const AuthoritiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 应用和用户需要 WRITE_AUTHORITY 权限。
         * @summary 删除权限
         * @param {Array<number>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthorities: async (requestBody: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            if (requestBody === null || requestBody === undefined) {
                throw new RequiredError('requestBody','Required parameter requestBody was null or undefined when calling deleteAuthorities.');
            }
            const localVarPath = `/v1/authorities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof requestBody !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(requestBody !== undefined ? requestBody : {})
                : (requestBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 GRANT_CLIENT 权限。
         * @summary 删除应用权限
         * @param {string} cid 
         * @param {Array<number>} authorityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClientAuthorities: async (cid: string, authorityId: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling deleteClientAuthorities.');
            }
            // verify required parameter 'authorityId' is not null or undefined
            if (authorityId === null || authorityId === undefined) {
                throw new RequiredError('authorityId','Required parameter authorityId was null or undefined when calling deleteClientAuthorities.');
            }
            const localVarPath = `/v1/clients/{cid}/authorities`
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (authorityId) {
                localVarQueryParameter['authorityId'] = authorityId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 GRANT_ROLE 权限。
         * @summary 删除角色权限
         * @param {number} rid 
         * @param {Array<number>} authorityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleAuthorities: async (rid: number, authorityId: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rid' is not null or undefined
            if (rid === null || rid === undefined) {
                throw new RequiredError('rid','Required parameter rid was null or undefined when calling deleteRoleAuthorities.');
            }
            // verify required parameter 'authorityId' is not null or undefined
            if (authorityId === null || authorityId === undefined) {
                throw new RequiredError('authorityId','Required parameter authorityId was null or undefined when calling deleteRoleAuthorities.');
            }
            const localVarPath = `/v1/roles/{rid}/authorities`
                .replace(`{${"rid"}}`, encodeURIComponent(String(rid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (authorityId) {
                localVarQueryParameter['authorityId'] = authorityId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 获取权限
         * @param {Array<number>} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorities: async (id?: Array<number>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/authorities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 READ_CLIENT 权限。
         * @summary 获取应用权限
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientAuthorities: async (cid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling getClientAuthorities.');
            }
            const localVarPath = `/v1/clients/{cid}/authorities`
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 获取角色权限
         * @param {number} rid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAuthorities: async (rid: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rid' is not null or undefined
            if (rid === null || rid === undefined) {
                throw new RequiredError('rid','Required parameter rid was null or undefined when calling getRoleAuthorities.');
            }
            const localVarPath = `/v1/roles/{rid}/authorities`
                .replace(`{${"rid"}}`, encodeURIComponent(String(rid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
         * @summary 获取应用权限
         * @param {number} uid 
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserClientAuthorities: async (uid: number, cid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling getUserClientAuthorities.');
            }
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling getUserClientAuthorities.');
            }
            const localVarPath = `/v1/users/{uid}/clients/{cid}/authorities`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 WRITE_AUTHORITY 权限。
         * @summary 修改或添加权限
         * @param {Array<Authority>} authority 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAuthorities: async (authority: Array<Authority>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authority' is not null or undefined
            if (authority === null || authority === undefined) {
                throw new RequiredError('authority','Required parameter authority was null or undefined when calling setAuthorities.');
            }
            const localVarPath = `/v1/authorities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof authority !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(authority !== undefined ? authority : {})
                : (authority || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 GRANT_CLIENT 权限。
         * @summary 添加应用权限
         * @param {string} cid 
         * @param {Array<number>} authorityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setClientAuthorities: async (cid: string, authorityId: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling setClientAuthorities.');
            }
            // verify required parameter 'authorityId' is not null or undefined
            if (authorityId === null || authorityId === undefined) {
                throw new RequiredError('authorityId','Required parameter authorityId was null or undefined when calling setClientAuthorities.');
            }
            const localVarPath = `/v1/clients/{cid}/authorities`
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (authorityId) {
                localVarQueryParameter['authorityId'] = authorityId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 GRANT_ROLE 权限。
         * @summary 添加角色权限
         * @param {number} rid 
         * @param {Array<number>} authorityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRoleAuthorities: async (rid: number, authorityId: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rid' is not null or undefined
            if (rid === null || rid === undefined) {
                throw new RequiredError('rid','Required parameter rid was null or undefined when calling setRoleAuthorities.');
            }
            // verify required parameter 'authorityId' is not null or undefined
            if (authorityId === null || authorityId === undefined) {
                throw new RequiredError('authorityId','Required parameter authorityId was null or undefined when calling setRoleAuthorities.');
            }
            const localVarPath = `/v1/roles/{rid}/authorities`
                .replace(`{${"rid"}}`, encodeURIComponent(String(rid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (authorityId) {
                localVarQueryParameter['authorityId'] = authorityId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthoritiesApi - functional programming interface
 * @export
 */
export const AuthoritiesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 应用和用户需要 WRITE_AUTHORITY 权限。
         * @summary 删除权限
         * @param {Array<number>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAuthorities(requestBody: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthoritiesApiAxiosParamCreator(configuration).deleteAuthorities(requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 GRANT_CLIENT 权限。
         * @summary 删除应用权限
         * @param {string} cid 
         * @param {Array<number>} authorityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteClientAuthorities(cid: string, authorityId: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthoritiesApiAxiosParamCreator(configuration).deleteClientAuthorities(cid, authorityId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 GRANT_ROLE 权限。
         * @summary 删除角色权限
         * @param {number} rid 
         * @param {Array<number>} authorityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoleAuthorities(rid: number, authorityId: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthoritiesApiAxiosParamCreator(configuration).deleteRoleAuthorities(rid, authorityId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary 获取权限
         * @param {Array<number>} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthorities(id?: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Authority>>> {
            const localVarAxiosArgs = await AuthoritiesApiAxiosParamCreator(configuration).getAuthorities(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 READ_CLIENT 权限。
         * @summary 获取应用权限
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientAuthorities(cid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await AuthoritiesApiAxiosParamCreator(configuration).getClientAuthorities(cid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary 获取角色权限
         * @param {number} rid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleAuthorities(rid: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await AuthoritiesApiAxiosParamCreator(configuration).getRoleAuthorities(rid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
         * @summary 获取应用权限
         * @param {number} uid 
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserClientAuthorities(uid: number, cid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await AuthoritiesApiAxiosParamCreator(configuration).getUserClientAuthorities(uid, cid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 WRITE_AUTHORITY 权限。
         * @summary 修改或添加权限
         * @param {Array<Authority>} authority 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAuthorities(authority: Array<Authority>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthoritiesApiAxiosParamCreator(configuration).setAuthorities(authority, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 GRANT_CLIENT 权限。
         * @summary 添加应用权限
         * @param {string} cid 
         * @param {Array<number>} authorityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setClientAuthorities(cid: string, authorityId: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthoritiesApiAxiosParamCreator(configuration).setClientAuthorities(cid, authorityId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 GRANT_ROLE 权限。
         * @summary 添加角色权限
         * @param {number} rid 
         * @param {Array<number>} authorityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRoleAuthorities(rid: number, authorityId: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthoritiesApiAxiosParamCreator(configuration).setRoleAuthorities(rid, authorityId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AuthoritiesApi - factory interface
 * @export
 */
export const AuthoritiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 应用和用户需要 WRITE_AUTHORITY 权限。
         * @summary 删除权限
         * @param {Array<number>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthorities(requestBody: Array<number>, options?: any): AxiosPromise<void> {
            return AuthoritiesApiFp(configuration).deleteAuthorities(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 GRANT_CLIENT 权限。
         * @summary 删除应用权限
         * @param {string} cid 
         * @param {Array<number>} authorityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClientAuthorities(cid: string, authorityId: Array<number>, options?: any): AxiosPromise<void> {
            return AuthoritiesApiFp(configuration).deleteClientAuthorities(cid, authorityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 GRANT_ROLE 权限。
         * @summary 删除角色权限
         * @param {number} rid 
         * @param {Array<number>} authorityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleAuthorities(rid: number, authorityId: Array<number>, options?: any): AxiosPromise<void> {
            return AuthoritiesApiFp(configuration).deleteRoleAuthorities(rid, authorityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 获取权限
         * @param {Array<number>} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorities(id?: Array<number>, options?: any): AxiosPromise<Array<Authority>> {
            return AuthoritiesApiFp(configuration).getAuthorities(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 READ_CLIENT 权限。
         * @summary 获取应用权限
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientAuthorities(cid: string, options?: any): AxiosPromise<Array<string>> {
            return AuthoritiesApiFp(configuration).getClientAuthorities(cid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 获取角色权限
         * @param {number} rid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAuthorities(rid: number, options?: any): AxiosPromise<Array<string>> {
            return AuthoritiesApiFp(configuration).getRoleAuthorities(rid, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
         * @summary 获取应用权限
         * @param {number} uid 
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserClientAuthorities(uid: number, cid: string, options?: any): AxiosPromise<Array<string>> {
            return AuthoritiesApiFp(configuration).getUserClientAuthorities(uid, cid, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 WRITE_AUTHORITY 权限。
         * @summary 修改或添加权限
         * @param {Array<Authority>} authority 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAuthorities(authority: Array<Authority>, options?: any): AxiosPromise<void> {
            return AuthoritiesApiFp(configuration).setAuthorities(authority, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 GRANT_CLIENT 权限。
         * @summary 添加应用权限
         * @param {string} cid 
         * @param {Array<number>} authorityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setClientAuthorities(cid: string, authorityId: Array<number>, options?: any): AxiosPromise<void> {
            return AuthoritiesApiFp(configuration).setClientAuthorities(cid, authorityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 GRANT_ROLE 权限。
         * @summary 添加角色权限
         * @param {number} rid 
         * @param {Array<number>} authorityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRoleAuthorities(rid: number, authorityId: Array<number>, options?: any): AxiosPromise<void> {
            return AuthoritiesApiFp(configuration).setRoleAuthorities(rid, authorityId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthoritiesApi - object-oriented interface
 * @export
 * @class AuthoritiesApi
 * @extends {BaseAPI}
 */
export class AuthoritiesApi extends BaseAPI {
    /**
     * 应用和用户需要 WRITE_AUTHORITY 权限。
     * @summary 删除权限
     * @param {Array<number>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthoritiesApi
     */
    public deleteAuthorities(requestBody: Array<number>, options?: any) {
        return AuthoritiesApiFp(this.configuration).deleteAuthorities(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 GRANT_CLIENT 权限。
     * @summary 删除应用权限
     * @param {string} cid 
     * @param {Array<number>} authorityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthoritiesApi
     */
    public deleteClientAuthorities(cid: string, authorityId: Array<number>, options?: any) {
        return AuthoritiesApiFp(this.configuration).deleteClientAuthorities(cid, authorityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 GRANT_ROLE 权限。
     * @summary 删除角色权限
     * @param {number} rid 
     * @param {Array<number>} authorityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthoritiesApi
     */
    public deleteRoleAuthorities(rid: number, authorityId: Array<number>, options?: any) {
        return AuthoritiesApiFp(this.configuration).deleteRoleAuthorities(rid, authorityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 获取权限
     * @param {Array<number>} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthoritiesApi
     */
    public getAuthorities(id?: Array<number>, options?: any) {
        return AuthoritiesApiFp(this.configuration).getAuthorities(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 READ_CLIENT 权限。
     * @summary 获取应用权限
     * @param {string} cid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthoritiesApi
     */
    public getClientAuthorities(cid: string, options?: any) {
        return AuthoritiesApiFp(this.configuration).getClientAuthorities(cid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 获取角色权限
     * @param {number} rid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthoritiesApi
     */
    public getRoleAuthorities(rid: number, options?: any) {
        return AuthoritiesApiFp(this.configuration).getRoleAuthorities(rid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
     * @summary 获取应用权限
     * @param {number} uid 
     * @param {string} cid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthoritiesApi
     */
    public getUserClientAuthorities(uid: number, cid: string, options?: any) {
        return AuthoritiesApiFp(this.configuration).getUserClientAuthorities(uid, cid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 WRITE_AUTHORITY 权限。
     * @summary 修改或添加权限
     * @param {Array<Authority>} authority 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthoritiesApi
     */
    public setAuthorities(authority: Array<Authority>, options?: any) {
        return AuthoritiesApiFp(this.configuration).setAuthorities(authority, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 GRANT_CLIENT 权限。
     * @summary 添加应用权限
     * @param {string} cid 
     * @param {Array<number>} authorityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthoritiesApi
     */
    public setClientAuthorities(cid: string, authorityId: Array<number>, options?: any) {
        return AuthoritiesApiFp(this.configuration).setClientAuthorities(cid, authorityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 GRANT_ROLE 权限。
     * @summary 添加角色权限
     * @param {number} rid 
     * @param {Array<number>} authorityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthoritiesApi
     */
    public setRoleAuthorities(rid: number, authorityId: Array<number>, options?: any) {
        return AuthoritiesApiFp(this.configuration).setRoleAuthorities(rid, authorityId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthorizationApi - axios parameter creator
 * @export
 */
export const AuthorizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 应用需要 AUTHORIZE 权限。
         * @summary 应用授权
         * @param {boolean} approved 
         * @param {Set<string>} scope 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthorization: async (approved: boolean, scope: Set<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'approved' is not null or undefined
            if (approved === null || approved === undefined) {
                throw new RequiredError('approved','Required parameter approved was null or undefined when calling createAuthorization.');
            }
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling createAuthorization.');
            }
            const localVarPath = `/v1/oauth/authorization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (approved !== undefined) {
                localVarQueryParameter['approved'] = approved;
            }

            if (scope) {
                localVarQueryParameter['scope'] = scope;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 获取包含应用信息、所属用户信息、回调地址以及是否已授权。应用需要 AUTHORIZE 权限。
         * @summary 获取应用授权
         * @param {string} clientId 
         * @param {string} [responseType] 
         * @param {string} [redirectUri] 
         * @param {Array<string>} [scope] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorization: async (clientId: string, responseType?: string, redirectUri?: string, scope?: Array<string>, state?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new RequiredError('clientId','Required parameter clientId was null or undefined when calling getAuthorization.');
            }
            const localVarPath = `/v1/oauth/authorization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }

            if (responseType !== undefined) {
                localVarQueryParameter['response_type'] = responseType;
            }

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (scope) {
                localVarQueryParameter['scope'] = scope;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorizationApi - functional programming interface
 * @export
 */
export const AuthorizationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 应用需要 AUTHORIZE 权限。
         * @summary 应用授权
         * @param {boolean} approved 
         * @param {Set<string>} scope 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAuthorization(approved: boolean, scope: Set<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorizationResponse>> {
            const localVarAxiosArgs = await AuthorizationApiAxiosParamCreator(configuration).createAuthorization(approved, scope, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 获取包含应用信息、所属用户信息、回调地址以及是否已授权。应用需要 AUTHORIZE 权限。
         * @summary 获取应用授权
         * @param {string} clientId 
         * @param {string} [responseType] 
         * @param {string} [redirectUri] 
         * @param {Array<string>} [scope] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthorization(clientId: string, responseType?: string, redirectUri?: string, scope?: Array<string>, state?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorizationResponse>> {
            const localVarAxiosArgs = await AuthorizationApiAxiosParamCreator(configuration).getAuthorization(clientId, responseType, redirectUri, scope, state, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AuthorizationApi - factory interface
 * @export
 */
export const AuthorizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 应用需要 AUTHORIZE 权限。
         * @summary 应用授权
         * @param {boolean} approved 
         * @param {Set<string>} scope 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthorization(approved: boolean, scope: Set<string>, options?: any): AxiosPromise<AuthorizationResponse> {
            return AuthorizationApiFp(configuration).createAuthorization(approved, scope, options).then((request) => request(axios, basePath));
        },
        /**
         * 获取包含应用信息、所属用户信息、回调地址以及是否已授权。应用需要 AUTHORIZE 权限。
         * @summary 获取应用授权
         * @param {string} clientId 
         * @param {string} [responseType] 
         * @param {string} [redirectUri] 
         * @param {Array<string>} [scope] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorization(clientId: string, responseType?: string, redirectUri?: string, scope?: Array<string>, state?: string, options?: any): AxiosPromise<AuthorizationResponse> {
            return AuthorizationApiFp(configuration).getAuthorization(clientId, responseType, redirectUri, scope, state, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthorizationApi - object-oriented interface
 * @export
 * @class AuthorizationApi
 * @extends {BaseAPI}
 */
export class AuthorizationApi extends BaseAPI {
    /**
     * 应用需要 AUTHORIZE 权限。
     * @summary 应用授权
     * @param {boolean} approved 
     * @param {Set<string>} scope 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public createAuthorization(approved: boolean, scope: Set<string>, options?: any) {
        return AuthorizationApiFp(this.configuration).createAuthorization(approved, scope, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 获取包含应用信息、所属用户信息、回调地址以及是否已授权。应用需要 AUTHORIZE 权限。
     * @summary 获取应用授权
     * @param {string} clientId 
     * @param {string} [responseType] 
     * @param {string} [redirectUri] 
     * @param {Array<string>} [scope] 
     * @param {string} [state] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public getAuthorization(clientId: string, responseType?: string, redirectUri?: string, scope?: Array<string>, state?: string, options?: any) {
        return AuthorizationApiFp(this.configuration).getAuthorization(clientId, responseType, redirectUri, scope, state, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClientsApi - axios parameter creator
 * @export
 */
export const ClientsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 创建应用
         * @param {number} uid 
         * @param {string} name 
         * @param {string} description 
         * @param {string} redirectUri 
         * @param {Array<number>} [scopes] 
         * @param {Array<number>} [grantTypes] 
         * @param {number} [accessTokenValidity] 
         * @param {number} [refreshTokenValidity] 
         * @param {string} [additionalInformation] 
         * @param {number} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClient: async (uid: number, name: string, description: string, redirectUri: string, scopes?: Array<number>, grantTypes?: Array<number>, accessTokenValidity?: number, refreshTokenValidity?: number, additionalInformation?: string, status?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling createClient.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling createClient.');
            }
            // verify required parameter 'description' is not null or undefined
            if (description === null || description === undefined) {
                throw new RequiredError('description','Required parameter description was null or undefined when calling createClient.');
            }
            // verify required parameter 'redirectUri' is not null or undefined
            if (redirectUri === null || redirectUri === undefined) {
                throw new RequiredError('redirectUri','Required parameter redirectUri was null or undefined when calling createClient.');
            }
            const localVarPath = `/v1/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirectUri'] = redirectUri;
            }

            if (scopes) {
                localVarQueryParameter['scopes'] = scopes;
            }

            if (grantTypes) {
                localVarQueryParameter['grantTypes'] = grantTypes;
            }

            if (accessTokenValidity !== undefined) {
                localVarQueryParameter['accessTokenValidity'] = accessTokenValidity;
            }

            if (refreshTokenValidity !== undefined) {
                localVarQueryParameter['refreshTokenValidity'] = refreshTokenValidity;
            }

            if (additionalInformation !== undefined) {
                localVarQueryParameter['additionalInformation'] = additionalInformation;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限，或者应用拥有 WRITE_CLIENT 权限且 uid 为当前用户并拥有 CREATE_CLIENT 权限）
         * @summary 创建用户应用
         * @param {number} uid 
         * @param {string} name 
         * @param {string} description 
         * @param {string} redirectUri 
         * @param {Array<number>} [scopes] 
         * @param {Array<number>} [grantTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserClient: async (uid: number, name: string, description: string, redirectUri: string, scopes?: Array<number>, grantTypes?: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling createUserClient.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling createUserClient.');
            }
            // verify required parameter 'description' is not null or undefined
            if (description === null || description === undefined) {
                throw new RequiredError('description','Required parameter description was null or undefined when calling createUserClient.');
            }
            // verify required parameter 'redirectUri' is not null or undefined
            if (redirectUri === null || redirectUri === undefined) {
                throw new RequiredError('redirectUri','Required parameter redirectUri was null or undefined when calling createUserClient.');
            }
            const localVarPath = `/v1/users/{uid}/clients`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirectUri'] = redirectUri;
            }

            if (scopes) {
                localVarQueryParameter['scopes'] = scopes;
            }

            if (grantTypes) {
                localVarQueryParameter['grantTypes'] = grantTypes;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 READ_CLIENT 权限。
         * @summary 获取应用
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClient: async (cid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling getClient.');
            }
            const localVarPath = `/v1/clients/{cid}`
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 获取应用 Logo
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientLogo: async (cid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling getClientLogo.');
            }
            const localVarPath = `/v1/clients/{cid}/logo`
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 READ_CLIENT 权限。
         * @summary 查询应用
         * @param {string} [q] 
         * @param {Array<string>} [order] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClients: async (q?: string, order?: Array<string>, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (order) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
         * @summary 获取用户应用
         * @param {number} uid 
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserClient: async (uid: number, cid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling getUserClient.');
            }
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling getUserClient.');
            }
            const localVarPath = `/v1/users/{uid}/clients/{cid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
         * @summary 获取用户应用 Logo
         * @param {number} uid 
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserClientLogo: async (uid: number, cid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling getUserClientLogo.');
            }
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling getUserClientLogo.');
            }
            const localVarPath = `/v1/users/{uid}/clients/{cid}/logo`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
         * @summary 查询用户应用
         * @param {number} uid 
         * @param {string} [q] 
         * @param {Array<string>} [order] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserClients: async (uid: number, q?: string, order?: Array<string>, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling getUserClients.');
            }
            const localVarPath = `/v1/users/{uid}/clients`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (order) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 删除应用
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeClient: async (cid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling removeClient.');
            }
            const localVarPath = `/v1/clients/{cid}`
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 删除应用
         * @param {Array<string>} cids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeClients: async (cids: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cids' is not null or undefined
            if (cids === null || cids === undefined) {
                throw new RequiredError('cids','Required parameter cids was null or undefined when calling removeClients.');
            }
            const localVarPath = `/v1/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (cids) {
                localVarQueryParameter['cids'] = cids;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 删除用户应用
         * @param {number} uid 
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserClient: async (uid: number, cid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling removeUserClient.');
            }
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling removeUserClient.');
            }
            const localVarPath = `/v1/users/{uid}/clients/{cid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
         * @summary 删除用户应用
         * @param {number} uid 
         * @param {Array<string>} cids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserClients: async (uid: number, cids: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling removeUserClients.');
            }
            // verify required parameter 'cids' is not null or undefined
            if (cids === null || cids === undefined) {
                throw new RequiredError('cids','Required parameter cids was null or undefined when calling removeUserClients.');
            }
            const localVarPath = `/v1/users/{uid}/clients`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (cids) {
                localVarQueryParameter['cids'] = cids;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 更新应用AccessToken有效期
         * @param {string} cid 
         * @param {number} accessTokenValidity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientAccessTokenValidity: async (cid: string, accessTokenValidity: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling updateClientAccessTokenValidity.');
            }
            // verify required parameter 'accessTokenValidity' is not null or undefined
            if (accessTokenValidity === null || accessTokenValidity === undefined) {
                throw new RequiredError('accessTokenValidity','Required parameter accessTokenValidity was null or undefined when calling updateClientAccessTokenValidity.');
            }
            const localVarPath = `/v1/clients/{cid}/access-token-validity`
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accessTokenValidity !== undefined) {
                localVarQueryParameter['accessTokenValidity'] = accessTokenValidity;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 更新应用描述
         * @param {string} cid 
         * @param {string} description 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientDescription: async (cid: string, description: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling updateClientDescription.');
            }
            // verify required parameter 'description' is not null or undefined
            if (description === null || description === undefined) {
                throw new RequiredError('description','Required parameter description was null or undefined when calling updateClientDescription.');
            }
            const localVarPath = `/v1/clients/{cid}/description`
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 更新应用 Logo
         * @param {string} cid 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientLogo: async (cid: string, body: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling updateClientLogo.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateClientLogo.');
            }
            const localVarPath = `/v1/clients/{cid}/logo`
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'image/_*';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 更新应用名称
         * @param {string} cid 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientName: async (cid: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling updateClientName.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateClientName.');
            }
            const localVarPath = `/v1/clients/{cid}/name`
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 更新应用回调地址
         * @param {string} cid 
         * @param {string} redirectUri 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientRedirectUri: async (cid: string, redirectUri: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling updateClientRedirectUri.');
            }
            // verify required parameter 'redirectUri' is not null or undefined
            if (redirectUri === null || redirectUri === undefined) {
                throw new RequiredError('redirectUri','Required parameter redirectUri was null or undefined when calling updateClientRedirectUri.');
            }
            const localVarPath = `/v1/clients/{cid}/redirect`
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirectUri'] = redirectUri;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 更新应用RefreshToken有效期
         * @param {string} cid 
         * @param {number} refreshTokenValidity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientRefreshTokenValidity: async (cid: string, refreshTokenValidity: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling updateClientRefreshTokenValidity.');
            }
            // verify required parameter 'refreshTokenValidity' is not null or undefined
            if (refreshTokenValidity === null || refreshTokenValidity === undefined) {
                throw new RequiredError('refreshTokenValidity','Required parameter refreshTokenValidity was null or undefined when calling updateClientRefreshTokenValidity.');
            }
            const localVarPath = `/v1/clients/{cid}/refresh-token-validity`
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (refreshTokenValidity !== undefined) {
                localVarQueryParameter['refreshTokenValidity'] = refreshTokenValidity;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 更新应用密钥
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientSecret: async (cid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling updateClientSecret.');
            }
            const localVarPath = `/v1/clients/{cid}/secret`
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 更新应用状态
         * @param {string} cid 
         * @param {number} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientStatus: async (cid: string, status: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling updateClientStatus.');
            }
            // verify required parameter 'status' is not null or undefined
            if (status === null || status === undefined) {
                throw new RequiredError('status','Required parameter status was null or undefined when calling updateClientStatus.');
            }
            const localVarPath = `/v1/clients/{cid}/status`
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 更新用户应用描述
         * @param {number} uid 
         * @param {string} cid 
         * @param {string} description 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserClientDescription: async (uid: number, cid: string, description: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling updateUserClientDescription.');
            }
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling updateUserClientDescription.');
            }
            // verify required parameter 'description' is not null or undefined
            if (description === null || description === undefined) {
                throw new RequiredError('description','Required parameter description was null or undefined when calling updateUserClientDescription.');
            }
            const localVarPath = `/v1/users/{uid}/clients/{cid}/description`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 更新用户应用 Logo
         * @param {number} uid 
         * @param {string} cid 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserClientLogo: async (uid: number, cid: string, body: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling updateUserClientLogo.');
            }
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling updateUserClientLogo.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateUserClientLogo.');
            }
            const localVarPath = `/v1/users/{uid}/clients/{cid}/logo`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'image/_*';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 更新用户应用名称
         * @param {number} uid 
         * @param {string} cid 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserClientName: async (uid: number, cid: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling updateUserClientName.');
            }
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling updateUserClientName.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateUserClientName.');
            }
            const localVarPath = `/v1/users/{uid}/clients/{cid}/name`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 更新用户应用回调地址
         * @param {number} uid 
         * @param {string} cid 
         * @param {string} redirectUri 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserClientRedirectUri: async (uid: number, cid: string, redirectUri: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling updateUserClientRedirectUri.');
            }
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling updateUserClientRedirectUri.');
            }
            // verify required parameter 'redirectUri' is not null or undefined
            if (redirectUri === null || redirectUri === undefined) {
                throw new RequiredError('redirectUri','Required parameter redirectUri was null or undefined when calling updateUserClientRedirectUri.');
            }
            const localVarPath = `/v1/users/{uid}/clients/{cid}/redirect`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirectUri'] = redirectUri;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 更新用户应用密钥
         * @param {number} uid 
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserClientSecret: async (uid: number, cid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling updateUserClientSecret.');
            }
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling updateUserClientSecret.');
            }
            const localVarPath = `/v1/users/{uid}/clients/{cid}/secret`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientsApi - functional programming interface
 * @export
 */
export const ClientsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 创建应用
         * @param {number} uid 
         * @param {string} name 
         * @param {string} description 
         * @param {string} redirectUri 
         * @param {Array<number>} [scopes] 
         * @param {Array<number>} [grantTypes] 
         * @param {number} [accessTokenValidity] 
         * @param {number} [refreshTokenValidity] 
         * @param {string} [additionalInformation] 
         * @param {number} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createClient(uid: number, name: string, description: string, redirectUri: string, scopes?: Array<number>, grantTypes?: Array<number>, accessTokenValidity?: number, refreshTokenValidity?: number, additionalInformation?: string, status?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).createClient(uid, name, description, redirectUri, scopes, grantTypes, accessTokenValidity, refreshTokenValidity, additionalInformation, status, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限，或者应用拥有 WRITE_CLIENT 权限且 uid 为当前用户并拥有 CREATE_CLIENT 权限）
         * @summary 创建用户应用
         * @param {number} uid 
         * @param {string} name 
         * @param {string} description 
         * @param {string} redirectUri 
         * @param {Array<number>} [scopes] 
         * @param {Array<number>} [grantTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserClient(uid: number, name: string, description: string, redirectUri: string, scopes?: Array<number>, grantTypes?: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).createUserClient(uid, name, description, redirectUri, scopes, grantTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 READ_CLIENT 权限。
         * @summary 获取应用
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClient(cid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).getClient(cid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary 获取应用 Logo
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientLogo(cid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).getClientLogo(cid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 READ_CLIENT 权限。
         * @summary 查询应用
         * @param {string} [q] 
         * @param {Array<string>} [order] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClients(q?: string, order?: Array<string>, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultsClient>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).getClients(q, order, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
         * @summary 获取用户应用
         * @param {number} uid 
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserClient(uid: number, cid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).getUserClient(uid, cid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
         * @summary 获取用户应用 Logo
         * @param {number} uid 
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserClientLogo(uid: number, cid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).getUserClientLogo(uid, cid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
         * @summary 查询用户应用
         * @param {number} uid 
         * @param {string} [q] 
         * @param {Array<string>} [order] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserClients(uid: number, q?: string, order?: Array<string>, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultsClient>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).getUserClients(uid, q, order, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 删除应用
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeClient(cid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).removeClient(cid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 删除应用
         * @param {Array<string>} cids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeClients(cids: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).removeClients(cids, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 删除用户应用
         * @param {number} uid 
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserClient(uid: number, cid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).removeUserClient(uid, cid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
         * @summary 删除用户应用
         * @param {number} uid 
         * @param {Array<string>} cids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserClients(uid: number, cids: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).removeUserClients(uid, cids, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 更新应用AccessToken有效期
         * @param {string} cid 
         * @param {number} accessTokenValidity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateClientAccessTokenValidity(cid: string, accessTokenValidity: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).updateClientAccessTokenValidity(cid, accessTokenValidity, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 更新应用描述
         * @param {string} cid 
         * @param {string} description 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateClientDescription(cid: string, description: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).updateClientDescription(cid, description, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 更新应用 Logo
         * @param {string} cid 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateClientLogo(cid: string, body: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).updateClientLogo(cid, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 更新应用名称
         * @param {string} cid 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateClientName(cid: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).updateClientName(cid, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 更新应用回调地址
         * @param {string} cid 
         * @param {string} redirectUri 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateClientRedirectUri(cid: string, redirectUri: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).updateClientRedirectUri(cid, redirectUri, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 更新应用RefreshToken有效期
         * @param {string} cid 
         * @param {number} refreshTokenValidity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateClientRefreshTokenValidity(cid: string, refreshTokenValidity: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).updateClientRefreshTokenValidity(cid, refreshTokenValidity, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 更新应用密钥
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateClientSecret(cid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).updateClientSecret(cid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 更新应用状态
         * @param {string} cid 
         * @param {number} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateClientStatus(cid: string, status: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).updateClientStatus(cid, status, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 更新用户应用描述
         * @param {number} uid 
         * @param {string} cid 
         * @param {string} description 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserClientDescription(uid: number, cid: string, description: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).updateUserClientDescription(uid, cid, description, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 更新用户应用 Logo
         * @param {number} uid 
         * @param {string} cid 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserClientLogo(uid: number, cid: string, body: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).updateUserClientLogo(uid, cid, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 更新用户应用名称
         * @param {number} uid 
         * @param {string} cid 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserClientName(uid: number, cid: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).updateUserClientName(uid, cid, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 更新用户应用回调地址
         * @param {number} uid 
         * @param {string} cid 
         * @param {string} redirectUri 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserClientRedirectUri(uid: number, cid: string, redirectUri: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).updateUserClientRedirectUri(uid, cid, redirectUri, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 更新用户应用密钥
         * @param {number} uid 
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserClientSecret(uid: number, cid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).updateUserClientSecret(uid, cid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ClientsApi - factory interface
 * @export
 */
export const ClientsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 创建应用
         * @param {number} uid 
         * @param {string} name 
         * @param {string} description 
         * @param {string} redirectUri 
         * @param {Array<number>} [scopes] 
         * @param {Array<number>} [grantTypes] 
         * @param {number} [accessTokenValidity] 
         * @param {number} [refreshTokenValidity] 
         * @param {string} [additionalInformation] 
         * @param {number} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClient(uid: number, name: string, description: string, redirectUri: string, scopes?: Array<number>, grantTypes?: Array<number>, accessTokenValidity?: number, refreshTokenValidity?: number, additionalInformation?: string, status?: number, options?: any): AxiosPromise<Client> {
            return ClientsApiFp(configuration).createClient(uid, name, description, redirectUri, scopes, grantTypes, accessTokenValidity, refreshTokenValidity, additionalInformation, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限，或者应用拥有 WRITE_CLIENT 权限且 uid 为当前用户并拥有 CREATE_CLIENT 权限）
         * @summary 创建用户应用
         * @param {number} uid 
         * @param {string} name 
         * @param {string} description 
         * @param {string} redirectUri 
         * @param {Array<number>} [scopes] 
         * @param {Array<number>} [grantTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserClient(uid: number, name: string, description: string, redirectUri: string, scopes?: Array<number>, grantTypes?: Array<number>, options?: any): AxiosPromise<Client> {
            return ClientsApiFp(configuration).createUserClient(uid, name, description, redirectUri, scopes, grantTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 READ_CLIENT 权限。
         * @summary 获取应用
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClient(cid: string, options?: any): AxiosPromise<Client> {
            return ClientsApiFp(configuration).getClient(cid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 获取应用 Logo
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientLogo(cid: string, options?: any): AxiosPromise<void> {
            return ClientsApiFp(configuration).getClientLogo(cid, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 READ_CLIENT 权限。
         * @summary 查询应用
         * @param {string} [q] 
         * @param {Array<string>} [order] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClients(q?: string, order?: Array<string>, offset?: number, limit?: number, options?: any): AxiosPromise<QueryResultsClient> {
            return ClientsApiFp(configuration).getClients(q, order, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
         * @summary 获取用户应用
         * @param {number} uid 
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserClient(uid: number, cid: string, options?: any): AxiosPromise<Client> {
            return ClientsApiFp(configuration).getUserClient(uid, cid, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
         * @summary 获取用户应用 Logo
         * @param {number} uid 
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserClientLogo(uid: number, cid: string, options?: any): AxiosPromise<void> {
            return ClientsApiFp(configuration).getUserClientLogo(uid, cid, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
         * @summary 查询用户应用
         * @param {number} uid 
         * @param {string} [q] 
         * @param {Array<string>} [order] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserClients(uid: number, q?: string, order?: Array<string>, offset?: number, limit?: number, options?: any): AxiosPromise<QueryResultsClient> {
            return ClientsApiFp(configuration).getUserClients(uid, q, order, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 删除应用
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeClient(cid: string, options?: any): AxiosPromise<void> {
            return ClientsApiFp(configuration).removeClient(cid, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 删除应用
         * @param {Array<string>} cids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeClients(cids: Array<string>, options?: any): AxiosPromise<void> {
            return ClientsApiFp(configuration).removeClients(cids, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 删除用户应用
         * @param {number} uid 
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserClient(uid: number, cid: string, options?: any): AxiosPromise<void> {
            return ClientsApiFp(configuration).removeUserClient(uid, cid, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
         * @summary 删除用户应用
         * @param {number} uid 
         * @param {Array<string>} cids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserClients(uid: number, cids: Array<string>, options?: any): AxiosPromise<void> {
            return ClientsApiFp(configuration).removeUserClients(uid, cids, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 更新应用AccessToken有效期
         * @param {string} cid 
         * @param {number} accessTokenValidity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientAccessTokenValidity(cid: string, accessTokenValidity: number, options?: any): AxiosPromise<void> {
            return ClientsApiFp(configuration).updateClientAccessTokenValidity(cid, accessTokenValidity, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 更新应用描述
         * @param {string} cid 
         * @param {string} description 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientDescription(cid: string, description: string, options?: any): AxiosPromise<void> {
            return ClientsApiFp(configuration).updateClientDescription(cid, description, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 更新应用 Logo
         * @param {string} cid 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientLogo(cid: string, body: any, options?: any): AxiosPromise<void> {
            return ClientsApiFp(configuration).updateClientLogo(cid, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 更新应用名称
         * @param {string} cid 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientName(cid: string, name: string, options?: any): AxiosPromise<void> {
            return ClientsApiFp(configuration).updateClientName(cid, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 更新应用回调地址
         * @param {string} cid 
         * @param {string} redirectUri 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientRedirectUri(cid: string, redirectUri: string, options?: any): AxiosPromise<void> {
            return ClientsApiFp(configuration).updateClientRedirectUri(cid, redirectUri, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 更新应用RefreshToken有效期
         * @param {string} cid 
         * @param {number} refreshTokenValidity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientRefreshTokenValidity(cid: string, refreshTokenValidity: number, options?: any): AxiosPromise<void> {
            return ClientsApiFp(configuration).updateClientRefreshTokenValidity(cid, refreshTokenValidity, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 更新应用密钥
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientSecret(cid: string, options?: any): AxiosPromise<string> {
            return ClientsApiFp(configuration).updateClientSecret(cid, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 更新应用状态
         * @param {string} cid 
         * @param {number} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientStatus(cid: string, status: number, options?: any): AxiosPromise<void> {
            return ClientsApiFp(configuration).updateClientStatus(cid, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 更新用户应用描述
         * @param {number} uid 
         * @param {string} cid 
         * @param {string} description 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserClientDescription(uid: number, cid: string, description: string, options?: any): AxiosPromise<void> {
            return ClientsApiFp(configuration).updateUserClientDescription(uid, cid, description, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 更新用户应用 Logo
         * @param {number} uid 
         * @param {string} cid 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserClientLogo(uid: number, cid: string, body: any, options?: any): AxiosPromise<void> {
            return ClientsApiFp(configuration).updateUserClientLogo(uid, cid, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 更新用户应用名称
         * @param {number} uid 
         * @param {string} cid 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserClientName(uid: number, cid: string, name: string, options?: any): AxiosPromise<void> {
            return ClientsApiFp(configuration).updateUserClientName(uid, cid, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 更新用户应用回调地址
         * @param {number} uid 
         * @param {string} cid 
         * @param {string} redirectUri 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserClientRedirectUri(uid: number, cid: string, redirectUri: string, options?: any): AxiosPromise<void> {
            return ClientsApiFp(configuration).updateUserClientRedirectUri(uid, cid, redirectUri, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 更新用户应用密钥
         * @param {number} uid 
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserClientSecret(uid: number, cid: string, options?: any): AxiosPromise<string> {
            return ClientsApiFp(configuration).updateUserClientSecret(uid, cid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientsApi - object-oriented interface
 * @export
 * @class ClientsApi
 * @extends {BaseAPI}
 */
export class ClientsApi extends BaseAPI {
    /**
     * 应用和用户需要 WRITE_CLIENT 权限。
     * @summary 创建应用
     * @param {number} uid 
     * @param {string} name 
     * @param {string} description 
     * @param {string} redirectUri 
     * @param {Array<number>} [scopes] 
     * @param {Array<number>} [grantTypes] 
     * @param {number} [accessTokenValidity] 
     * @param {number} [refreshTokenValidity] 
     * @param {string} [additionalInformation] 
     * @param {number} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public createClient(uid: number, name: string, description: string, redirectUri: string, scopes?: Array<number>, grantTypes?: Array<number>, accessTokenValidity?: number, refreshTokenValidity?: number, additionalInformation?: string, status?: number, options?: any) {
        return ClientsApiFp(this.configuration).createClient(uid, name, description, redirectUri, scopes, grantTypes, accessTokenValidity, refreshTokenValidity, additionalInformation, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 WRITE_CLIENT 权限，或者应用拥有 WRITE_CLIENT 权限且 uid 为当前用户并拥有 CREATE_CLIENT 权限）
     * @summary 创建用户应用
     * @param {number} uid 
     * @param {string} name 
     * @param {string} description 
     * @param {string} redirectUri 
     * @param {Array<number>} [scopes] 
     * @param {Array<number>} [grantTypes] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public createUserClient(uid: number, name: string, description: string, redirectUri: string, scopes?: Array<number>, grantTypes?: Array<number>, options?: any) {
        return ClientsApiFp(this.configuration).createUserClient(uid, name, description, redirectUri, scopes, grantTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 READ_CLIENT 权限。
     * @summary 获取应用
     * @param {string} cid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public getClient(cid: string, options?: any) {
        return ClientsApiFp(this.configuration).getClient(cid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 获取应用 Logo
     * @param {string} cid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public getClientLogo(cid: string, options?: any) {
        return ClientsApiFp(this.configuration).getClientLogo(cid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 READ_CLIENT 权限。
     * @summary 查询应用
     * @param {string} [q] 
     * @param {Array<string>} [order] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public getClients(q?: string, order?: Array<string>, offset?: number, limit?: number, options?: any) {
        return ClientsApiFp(this.configuration).getClients(q, order, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
     * @summary 获取用户应用
     * @param {number} uid 
     * @param {string} cid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public getUserClient(uid: number, cid: string, options?: any) {
        return ClientsApiFp(this.configuration).getUserClient(uid, cid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
     * @summary 获取用户应用 Logo
     * @param {number} uid 
     * @param {string} cid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public getUserClientLogo(uid: number, cid: string, options?: any) {
        return ClientsApiFp(this.configuration).getUserClientLogo(uid, cid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
     * @summary 查询用户应用
     * @param {number} uid 
     * @param {string} [q] 
     * @param {Array<string>} [order] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public getUserClients(uid: number, q?: string, order?: Array<string>, offset?: number, limit?: number, options?: any) {
        return ClientsApiFp(this.configuration).getUserClients(uid, q, order, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 WRITE_CLIENT 权限。
     * @summary 删除应用
     * @param {string} cid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public removeClient(cid: string, options?: any) {
        return ClientsApiFp(this.configuration).removeClient(cid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 WRITE_CLIENT 权限。
     * @summary 删除应用
     * @param {Array<string>} cids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public removeClients(cids: Array<string>, options?: any) {
        return ClientsApiFp(this.configuration).removeClients(cids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
     * @summary 删除用户应用
     * @param {number} uid 
     * @param {string} cid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public removeUserClient(uid: number, cid: string, options?: any) {
        return ClientsApiFp(this.configuration).removeUserClient(uid, cid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
     * @summary 删除用户应用
     * @param {number} uid 
     * @param {Array<string>} cids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public removeUserClients(uid: number, cids: Array<string>, options?: any) {
        return ClientsApiFp(this.configuration).removeUserClients(uid, cids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 WRITE_CLIENT 权限。
     * @summary 更新应用AccessToken有效期
     * @param {string} cid 
     * @param {number} accessTokenValidity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public updateClientAccessTokenValidity(cid: string, accessTokenValidity: number, options?: any) {
        return ClientsApiFp(this.configuration).updateClientAccessTokenValidity(cid, accessTokenValidity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 WRITE_CLIENT 权限。
     * @summary 更新应用描述
     * @param {string} cid 
     * @param {string} description 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public updateClientDescription(cid: string, description: string, options?: any) {
        return ClientsApiFp(this.configuration).updateClientDescription(cid, description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 WRITE_CLIENT 权限。
     * @summary 更新应用 Logo
     * @param {string} cid 
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public updateClientLogo(cid: string, body: any, options?: any) {
        return ClientsApiFp(this.configuration).updateClientLogo(cid, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 WRITE_CLIENT 权限。
     * @summary 更新应用名称
     * @param {string} cid 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public updateClientName(cid: string, name: string, options?: any) {
        return ClientsApiFp(this.configuration).updateClientName(cid, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 WRITE_CLIENT 权限。
     * @summary 更新应用回调地址
     * @param {string} cid 
     * @param {string} redirectUri 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public updateClientRedirectUri(cid: string, redirectUri: string, options?: any) {
        return ClientsApiFp(this.configuration).updateClientRedirectUri(cid, redirectUri, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 WRITE_CLIENT 权限。
     * @summary 更新应用RefreshToken有效期
     * @param {string} cid 
     * @param {number} refreshTokenValidity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public updateClientRefreshTokenValidity(cid: string, refreshTokenValidity: number, options?: any) {
        return ClientsApiFp(this.configuration).updateClientRefreshTokenValidity(cid, refreshTokenValidity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 WRITE_CLIENT 权限。
     * @summary 更新应用密钥
     * @param {string} cid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public updateClientSecret(cid: string, options?: any) {
        return ClientsApiFp(this.configuration).updateClientSecret(cid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 WRITE_CLIENT 权限。
     * @summary 更新应用状态
     * @param {string} cid 
     * @param {number} status 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public updateClientStatus(cid: string, status: number, options?: any) {
        return ClientsApiFp(this.configuration).updateClientStatus(cid, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
     * @summary 更新用户应用描述
     * @param {number} uid 
     * @param {string} cid 
     * @param {string} description 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public updateUserClientDescription(uid: number, cid: string, description: string, options?: any) {
        return ClientsApiFp(this.configuration).updateUserClientDescription(uid, cid, description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
     * @summary 更新用户应用 Logo
     * @param {number} uid 
     * @param {string} cid 
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public updateUserClientLogo(uid: number, cid: string, body: any, options?: any) {
        return ClientsApiFp(this.configuration).updateUserClientLogo(uid, cid, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
     * @summary 更新用户应用名称
     * @param {number} uid 
     * @param {string} cid 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public updateUserClientName(uid: number, cid: string, name: string, options?: any) {
        return ClientsApiFp(this.configuration).updateUserClientName(uid, cid, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
     * @summary 更新用户应用回调地址
     * @param {number} uid 
     * @param {string} cid 
     * @param {string} redirectUri 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public updateUserClientRedirectUri(uid: number, cid: string, redirectUri: string, options?: any) {
        return ClientsApiFp(this.configuration).updateUserClientRedirectUri(uid, cid, redirectUri, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
     * @summary 更新用户应用密钥
     * @param {number} uid 
     * @param {string} cid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public updateUserClientSecret(uid: number, cid: string, options?: any) {
        return ClientsApiFp(this.configuration).updateUserClientSecret(uid, cid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CodeApi - axios parameter creator
 * @export
 */
export const CodeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 发送验证码到邮箱，用于注册。
         * @summary 获取注册邮箱验证码
         * @param {string} gRecaptchaResponse 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRegistrationCode: async (gRecaptchaResponse: string, email: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'gRecaptchaResponse' is not null or undefined
            if (gRecaptchaResponse === null || gRecaptchaResponse === undefined) {
                throw new RequiredError('gRecaptchaResponse','Required parameter gRecaptchaResponse was null or undefined when calling createRegistrationCode.');
            }
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling createRegistrationCode.');
            }
            const localVarPath = `/v1/code/registration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (gRecaptchaResponse !== undefined) {
                localVarQueryParameter['g-recaptcha-response'] = gRecaptchaResponse;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 发送验证码到邮箱，用于更改邮箱。
         * @summary 获取更换邮箱验证码
         * @param {string} gRecaptchaResponse 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUpdateEmailCode: async (gRecaptchaResponse: string, email: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'gRecaptchaResponse' is not null or undefined
            if (gRecaptchaResponse === null || gRecaptchaResponse === undefined) {
                throw new RequiredError('gRecaptchaResponse','Required parameter gRecaptchaResponse was null or undefined when calling createUpdateEmailCode.');
            }
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling createUpdateEmailCode.');
            }
            const localVarPath = `/v1/code/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (gRecaptchaResponse !== undefined) {
                localVarQueryParameter['g-recaptcha-response'] = gRecaptchaResponse;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 发送验证码到邮箱，用于更改邮箱。
         * @summary 获取重置密码邮箱验证码
         * @param {string} gRecaptchaResponse 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUpdatePasswordEmailCode: async (gRecaptchaResponse: string, email: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'gRecaptchaResponse' is not null or undefined
            if (gRecaptchaResponse === null || gRecaptchaResponse === undefined) {
                throw new RequiredError('gRecaptchaResponse','Required parameter gRecaptchaResponse was null or undefined when calling createUpdatePasswordEmailCode.');
            }
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling createUpdatePasswordEmailCode.');
            }
            const localVarPath = `/v1/code/password/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (gRecaptchaResponse !== undefined) {
                localVarQueryParameter['g-recaptcha-response'] = gRecaptchaResponse;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CodeApi - functional programming interface
 * @export
 */
export const CodeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 发送验证码到邮箱，用于注册。
         * @summary 获取注册邮箱验证码
         * @param {string} gRecaptchaResponse 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRegistrationCode(gRecaptchaResponse: string, email: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CodeApiAxiosParamCreator(configuration).createRegistrationCode(gRecaptchaResponse, email, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 发送验证码到邮箱，用于更改邮箱。
         * @summary 获取更换邮箱验证码
         * @param {string} gRecaptchaResponse 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUpdateEmailCode(gRecaptchaResponse: string, email: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CodeApiAxiosParamCreator(configuration).createUpdateEmailCode(gRecaptchaResponse, email, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 发送验证码到邮箱，用于更改邮箱。
         * @summary 获取重置密码邮箱验证码
         * @param {string} gRecaptchaResponse 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUpdatePasswordEmailCode(gRecaptchaResponse: string, email: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CodeApiAxiosParamCreator(configuration).createUpdatePasswordEmailCode(gRecaptchaResponse, email, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CodeApi - factory interface
 * @export
 */
export const CodeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 发送验证码到邮箱，用于注册。
         * @summary 获取注册邮箱验证码
         * @param {string} gRecaptchaResponse 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRegistrationCode(gRecaptchaResponse: string, email: string, options?: any): AxiosPromise<void> {
            return CodeApiFp(configuration).createRegistrationCode(gRecaptchaResponse, email, options).then((request) => request(axios, basePath));
        },
        /**
         * 发送验证码到邮箱，用于更改邮箱。
         * @summary 获取更换邮箱验证码
         * @param {string} gRecaptchaResponse 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUpdateEmailCode(gRecaptchaResponse: string, email: string, options?: any): AxiosPromise<void> {
            return CodeApiFp(configuration).createUpdateEmailCode(gRecaptchaResponse, email, options).then((request) => request(axios, basePath));
        },
        /**
         * 发送验证码到邮箱，用于更改邮箱。
         * @summary 获取重置密码邮箱验证码
         * @param {string} gRecaptchaResponse 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUpdatePasswordEmailCode(gRecaptchaResponse: string, email: string, options?: any): AxiosPromise<void> {
            return CodeApiFp(configuration).createUpdatePasswordEmailCode(gRecaptchaResponse, email, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CodeApi - object-oriented interface
 * @export
 * @class CodeApi
 * @extends {BaseAPI}
 */
export class CodeApi extends BaseAPI {
    /**
     * 发送验证码到邮箱，用于注册。
     * @summary 获取注册邮箱验证码
     * @param {string} gRecaptchaResponse 
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeApi
     */
    public createRegistrationCode(gRecaptchaResponse: string, email: string, options?: any) {
        return CodeApiFp(this.configuration).createRegistrationCode(gRecaptchaResponse, email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 发送验证码到邮箱，用于更改邮箱。
     * @summary 获取更换邮箱验证码
     * @param {string} gRecaptchaResponse 
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeApi
     */
    public createUpdateEmailCode(gRecaptchaResponse: string, email: string, options?: any) {
        return CodeApiFp(this.configuration).createUpdateEmailCode(gRecaptchaResponse, email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 发送验证码到邮箱，用于更改邮箱。
     * @summary 获取重置密码邮箱验证码
     * @param {string} gRecaptchaResponse 
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeApi
     */
    public createUpdatePasswordEmailCode(gRecaptchaResponse: string, email: string, options?: any) {
        return CodeApiFp(this.configuration).createUpdatePasswordEmailCode(gRecaptchaResponse, email, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GrantTypesApi - axios parameter creator
 * @export
 */
export const GrantTypesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 添加应用授权模式
         * @param {string} cid 
         * @param {Array<number>} tid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addClientGrantTypes: async (cid: string, tid: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling addClientGrantTypes.');
            }
            // verify required parameter 'tid' is not null or undefined
            if (tid === null || tid === undefined) {
                throw new RequiredError('tid','Required parameter tid was null or undefined when calling addClientGrantTypes.');
            }
            const localVarPath = `/v1/clients/{cid}/types`
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (tid) {
                localVarQueryParameter['tid'] = tid;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 添加应用授权模式
         * @param {number} uid 
         * @param {string} cid 
         * @param {Array<number>} tid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserClientGrantTypes: async (uid: number, cid: string, tid: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling addUserClientGrantTypes.');
            }
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling addUserClientGrantTypes.');
            }
            // verify required parameter 'tid' is not null or undefined
            if (tid === null || tid === undefined) {
                throw new RequiredError('tid','Required parameter tid was null or undefined when calling addUserClientGrantTypes.');
            }
            const localVarPath = `/v1/users/{uid}/clients/{cid}/types`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (tid) {
                localVarQueryParameter['tid'] = tid;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 删除应用授权模式
         * @param {string} cid 
         * @param {Array<number>} tid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClientGrantTypes: async (cid: string, tid: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling deleteClientGrantTypes.');
            }
            // verify required parameter 'tid' is not null or undefined
            if (tid === null || tid === undefined) {
                throw new RequiredError('tid','Required parameter tid was null or undefined when calling deleteClientGrantTypes.');
            }
            const localVarPath = `/v1/clients/{cid}/types`
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (tid) {
                localVarQueryParameter['tid'] = tid;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 WRITE_TYPE 权限。
         * @summary 删除授权模式
         * @param {Array<number>} tid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGrantTypes: async (tid: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tid' is not null or undefined
            if (tid === null || tid === undefined) {
                throw new RequiredError('tid','Required parameter tid was null or undefined when calling deleteGrantTypes.');
            }
            const localVarPath = `/v1/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (tid) {
                localVarQueryParameter['tid'] = tid;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 删除应用授权模式
         * @param {number} uid 
         * @param {string} cid 
         * @param {Array<number>} tid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserClientGrantTypes: async (uid: number, cid: string, tid: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling deleteUserClientGrantTypes.');
            }
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling deleteUserClientGrantTypes.');
            }
            // verify required parameter 'tid' is not null or undefined
            if (tid === null || tid === undefined) {
                throw new RequiredError('tid','Required parameter tid was null or undefined when calling deleteUserClientGrantTypes.');
            }
            const localVarPath = `/v1/users/{uid}/clients/{cid}/types`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (tid) {
                localVarQueryParameter['tid'] = tid;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 READ_CLIENT 权限。
         * @summary 获取应用授权模式
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientGrantTypes: async (cid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling getClientGrantTypes.');
            }
            const localVarPath = `/v1/clients/{cid}/types`
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 获取授权模式
         * @param {Array<number>} [tid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrantTypes: async (tid?: Array<number>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (tid) {
                localVarQueryParameter['tid'] = tid;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
         * @summary 获取应用授权模式
         * @param {number} uid 
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserClientGrantTypes: async (uid: number, cid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling getUserClientGrantTypes.');
            }
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling getUserClientGrantTypes.');
            }
            const localVarPath = `/v1/users/{uid}/clients/{cid}/types`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 WRITE_TYPE 权限。
         * @summary 添加或修改授权模式
         * @param {Array<GrantType>} grantType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGrantTypes: async (grantType: Array<GrantType>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'grantType' is not null or undefined
            if (grantType === null || grantType === undefined) {
                throw new RequiredError('grantType','Required parameter grantType was null or undefined when calling setGrantTypes.');
            }
            const localVarPath = `/v1/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof grantType !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(grantType !== undefined ? grantType : {})
                : (grantType || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GrantTypesApi - functional programming interface
 * @export
 */
export const GrantTypesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 添加应用授权模式
         * @param {string} cid 
         * @param {Array<number>} tid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addClientGrantTypes(cid: string, tid: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GrantTypesApiAxiosParamCreator(configuration).addClientGrantTypes(cid, tid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 添加应用授权模式
         * @param {number} uid 
         * @param {string} cid 
         * @param {Array<number>} tid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserClientGrantTypes(uid: number, cid: string, tid: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GrantTypesApiAxiosParamCreator(configuration).addUserClientGrantTypes(uid, cid, tid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 删除应用授权模式
         * @param {string} cid 
         * @param {Array<number>} tid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteClientGrantTypes(cid: string, tid: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GrantTypesApiAxiosParamCreator(configuration).deleteClientGrantTypes(cid, tid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 WRITE_TYPE 权限。
         * @summary 删除授权模式
         * @param {Array<number>} tid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGrantTypes(tid: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GrantTypesApiAxiosParamCreator(configuration).deleteGrantTypes(tid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 删除应用授权模式
         * @param {number} uid 
         * @param {string} cid 
         * @param {Array<number>} tid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserClientGrantTypes(uid: number, cid: string, tid: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GrantTypesApiAxiosParamCreator(configuration).deleteUserClientGrantTypes(uid, cid, tid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 READ_CLIENT 权限。
         * @summary 获取应用授权模式
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientGrantTypes(cid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GrantType>>> {
            const localVarAxiosArgs = await GrantTypesApiAxiosParamCreator(configuration).getClientGrantTypes(cid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary 获取授权模式
         * @param {Array<number>} [tid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGrantTypes(tid?: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GrantType>>> {
            const localVarAxiosArgs = await GrantTypesApiAxiosParamCreator(configuration).getGrantTypes(tid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
         * @summary 获取应用授权模式
         * @param {number} uid 
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserClientGrantTypes(uid: number, cid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GrantType>>> {
            const localVarAxiosArgs = await GrantTypesApiAxiosParamCreator(configuration).getUserClientGrantTypes(uid, cid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 WRITE_TYPE 权限。
         * @summary 添加或修改授权模式
         * @param {Array<GrantType>} grantType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setGrantTypes(grantType: Array<GrantType>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GrantTypesApiAxiosParamCreator(configuration).setGrantTypes(grantType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GrantTypesApi - factory interface
 * @export
 */
export const GrantTypesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 添加应用授权模式
         * @param {string} cid 
         * @param {Array<number>} tid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addClientGrantTypes(cid: string, tid: Array<number>, options?: any): AxiosPromise<void> {
            return GrantTypesApiFp(configuration).addClientGrantTypes(cid, tid, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 添加应用授权模式
         * @param {number} uid 
         * @param {string} cid 
         * @param {Array<number>} tid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserClientGrantTypes(uid: number, cid: string, tid: Array<number>, options?: any): AxiosPromise<void> {
            return GrantTypesApiFp(configuration).addUserClientGrantTypes(uid, cid, tid, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 删除应用授权模式
         * @param {string} cid 
         * @param {Array<number>} tid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClientGrantTypes(cid: string, tid: Array<number>, options?: any): AxiosPromise<void> {
            return GrantTypesApiFp(configuration).deleteClientGrantTypes(cid, tid, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 WRITE_TYPE 权限。
         * @summary 删除授权模式
         * @param {Array<number>} tid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGrantTypes(tid: Array<number>, options?: any): AxiosPromise<void> {
            return GrantTypesApiFp(configuration).deleteGrantTypes(tid, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 删除应用授权模式
         * @param {number} uid 
         * @param {string} cid 
         * @param {Array<number>} tid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserClientGrantTypes(uid: number, cid: string, tid: Array<number>, options?: any): AxiosPromise<void> {
            return GrantTypesApiFp(configuration).deleteUserClientGrantTypes(uid, cid, tid, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 READ_CLIENT 权限。
         * @summary 获取应用授权模式
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientGrantTypes(cid: string, options?: any): AxiosPromise<Array<GrantType>> {
            return GrantTypesApiFp(configuration).getClientGrantTypes(cid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 获取授权模式
         * @param {Array<number>} [tid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrantTypes(tid?: Array<number>, options?: any): AxiosPromise<Array<GrantType>> {
            return GrantTypesApiFp(configuration).getGrantTypes(tid, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
         * @summary 获取应用授权模式
         * @param {number} uid 
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserClientGrantTypes(uid: number, cid: string, options?: any): AxiosPromise<Array<GrantType>> {
            return GrantTypesApiFp(configuration).getUserClientGrantTypes(uid, cid, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 WRITE_TYPE 权限。
         * @summary 添加或修改授权模式
         * @param {Array<GrantType>} grantType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGrantTypes(grantType: Array<GrantType>, options?: any): AxiosPromise<void> {
            return GrantTypesApiFp(configuration).setGrantTypes(grantType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GrantTypesApi - object-oriented interface
 * @export
 * @class GrantTypesApi
 * @extends {BaseAPI}
 */
export class GrantTypesApi extends BaseAPI {
    /**
     * 应用和用户需要 WRITE_CLIENT 权限。
     * @summary 添加应用授权模式
     * @param {string} cid 
     * @param {Array<number>} tid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GrantTypesApi
     */
    public addClientGrantTypes(cid: string, tid: Array<number>, options?: any) {
        return GrantTypesApiFp(this.configuration).addClientGrantTypes(cid, tid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
     * @summary 添加应用授权模式
     * @param {number} uid 
     * @param {string} cid 
     * @param {Array<number>} tid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GrantTypesApi
     */
    public addUserClientGrantTypes(uid: number, cid: string, tid: Array<number>, options?: any) {
        return GrantTypesApiFp(this.configuration).addUserClientGrantTypes(uid, cid, tid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 WRITE_CLIENT 权限。
     * @summary 删除应用授权模式
     * @param {string} cid 
     * @param {Array<number>} tid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GrantTypesApi
     */
    public deleteClientGrantTypes(cid: string, tid: Array<number>, options?: any) {
        return GrantTypesApiFp(this.configuration).deleteClientGrantTypes(cid, tid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 WRITE_TYPE 权限。
     * @summary 删除授权模式
     * @param {Array<number>} tid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GrantTypesApi
     */
    public deleteGrantTypes(tid: Array<number>, options?: any) {
        return GrantTypesApiFp(this.configuration).deleteGrantTypes(tid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
     * @summary 删除应用授权模式
     * @param {number} uid 
     * @param {string} cid 
     * @param {Array<number>} tid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GrantTypesApi
     */
    public deleteUserClientGrantTypes(uid: number, cid: string, tid: Array<number>, options?: any) {
        return GrantTypesApiFp(this.configuration).deleteUserClientGrantTypes(uid, cid, tid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 READ_CLIENT 权限。
     * @summary 获取应用授权模式
     * @param {string} cid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GrantTypesApi
     */
    public getClientGrantTypes(cid: string, options?: any) {
        return GrantTypesApiFp(this.configuration).getClientGrantTypes(cid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 获取授权模式
     * @param {Array<number>} [tid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GrantTypesApi
     */
    public getGrantTypes(tid?: Array<number>, options?: any) {
        return GrantTypesApiFp(this.configuration).getGrantTypes(tid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
     * @summary 获取应用授权模式
     * @param {number} uid 
     * @param {string} cid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GrantTypesApi
     */
    public getUserClientGrantTypes(uid: number, cid: string, options?: any) {
        return GrantTypesApiFp(this.configuration).getUserClientGrantTypes(uid, cid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 WRITE_TYPE 权限。
     * @summary 添加或修改授权模式
     * @param {Array<GrantType>} grantType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GrantTypesApi
     */
    public setGrantTypes(grantType: Array<GrantType>, options?: any) {
        return GrantTypesApiFp(this.configuration).setGrantTypes(grantType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 应用和用户需要 WRITE_ROLE 权限。
         * @summary 删除角色
         * @param {Array<number>} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoles: async (id: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteRoles.');
            }
            const localVarPath = `/v1/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 GRANT_USER 权限。
         * @summary 删除用户的角色
         * @param {number} uid 
         * @param {Array<number>} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserRoles: async (uid: number, id: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling deleteUserRoles.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteUserRoles.');
            }
            const localVarPath = `/v1/users/{uid}/roles`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 获取角色
         * @param {Array<number>} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles: async (id?: Array<number>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 READ_USER 权限。
         * @summary 获取用户角色
         * @param {number} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles: async (uid: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling getUserRoles.');
            }
            const localVarPath = `/v1/users/{uid}/roles`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 WRITE_ROLE 权限。
         * @summary 修改或添加角色
         * @param {Array<Role>} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRoles: async (role: Array<Role>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling setRoles.');
            }
            const localVarPath = `/v1/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof role !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(role !== undefined ? role : {})
                : (role || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 GRANT_USER 权限。
         * @summary 为用户添加角色
         * @param {number} uid 
         * @param {Array<UserRole>} userRole 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserRoles: async (uid: number, userRole: Array<UserRole>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling setUserRoles.');
            }
            // verify required parameter 'userRole' is not null or undefined
            if (userRole === null || userRole === undefined) {
                throw new RequiredError('userRole','Required parameter userRole was null or undefined when calling setUserRoles.');
            }
            const localVarPath = `/v1/users/{uid}/roles`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof userRole !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(userRole !== undefined ? userRole : {})
                : (userRole || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 应用和用户需要 WRITE_ROLE 权限。
         * @summary 删除角色
         * @param {Array<number>} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoles(id: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RolesApiAxiosParamCreator(configuration).deleteRoles(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 GRANT_USER 权限。
         * @summary 删除用户的角色
         * @param {number} uid 
         * @param {Array<number>} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserRoles(uid: number, id: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RolesApiAxiosParamCreator(configuration).deleteUserRoles(uid, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary 获取角色
         * @param {Array<number>} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoles(id?: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Role>>> {
            const localVarAxiosArgs = await RolesApiAxiosParamCreator(configuration).getRoles(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 READ_USER 权限。
         * @summary 获取用户角色
         * @param {number} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRoles(uid: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Role>>> {
            const localVarAxiosArgs = await RolesApiAxiosParamCreator(configuration).getUserRoles(uid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 WRITE_ROLE 权限。
         * @summary 修改或添加角色
         * @param {Array<Role>} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRoles(role: Array<Role>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RolesApiAxiosParamCreator(configuration).setRoles(role, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 GRANT_USER 权限。
         * @summary 为用户添加角色
         * @param {number} uid 
         * @param {Array<UserRole>} userRole 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserRoles(uid: number, userRole: Array<UserRole>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RolesApiAxiosParamCreator(configuration).setUserRoles(uid, userRole, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 应用和用户需要 WRITE_ROLE 权限。
         * @summary 删除角色
         * @param {Array<number>} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoles(id: Array<number>, options?: any): AxiosPromise<void> {
            return RolesApiFp(configuration).deleteRoles(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 GRANT_USER 权限。
         * @summary 删除用户的角色
         * @param {number} uid 
         * @param {Array<number>} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserRoles(uid: number, id: Array<number>, options?: any): AxiosPromise<void> {
            return RolesApiFp(configuration).deleteUserRoles(uid, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 获取角色
         * @param {Array<number>} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles(id?: Array<number>, options?: any): AxiosPromise<Array<Role>> {
            return RolesApiFp(configuration).getRoles(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 READ_USER 权限。
         * @summary 获取用户角色
         * @param {number} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles(uid: number, options?: any): AxiosPromise<Array<Role>> {
            return RolesApiFp(configuration).getUserRoles(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 WRITE_ROLE 权限。
         * @summary 修改或添加角色
         * @param {Array<Role>} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRoles(role: Array<Role>, options?: any): AxiosPromise<void> {
            return RolesApiFp(configuration).setRoles(role, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 GRANT_USER 权限。
         * @summary 为用户添加角色
         * @param {number} uid 
         * @param {Array<UserRole>} userRole 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserRoles(uid: number, userRole: Array<UserRole>, options?: any): AxiosPromise<void> {
            return RolesApiFp(configuration).setUserRoles(uid, userRole, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * 应用和用户需要 WRITE_ROLE 权限。
     * @summary 删除角色
     * @param {Array<number>} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public deleteRoles(id: Array<number>, options?: any) {
        return RolesApiFp(this.configuration).deleteRoles(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 GRANT_USER 权限。
     * @summary 删除用户的角色
     * @param {number} uid 
     * @param {Array<number>} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public deleteUserRoles(uid: number, id: Array<number>, options?: any) {
        return RolesApiFp(this.configuration).deleteUserRoles(uid, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 获取角色
     * @param {Array<number>} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRoles(id?: Array<number>, options?: any) {
        return RolesApiFp(this.configuration).getRoles(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户（uid 为当前用户除外）需要 READ_USER 权限。
     * @summary 获取用户角色
     * @param {number} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getUserRoles(uid: number, options?: any) {
        return RolesApiFp(this.configuration).getUserRoles(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 WRITE_ROLE 权限。
     * @summary 修改或添加角色
     * @param {Array<Role>} role 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public setRoles(role: Array<Role>, options?: any) {
        return RolesApiFp(this.configuration).setRoles(role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 GRANT_USER 权限。
     * @summary 为用户添加角色
     * @param {number} uid 
     * @param {Array<UserRole>} userRole 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public setUserRoles(uid: number, userRole: Array<UserRole>, options?: any) {
        return RolesApiFp(this.configuration).setUserRoles(uid, userRole, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ScopesApi - axios parameter creator
 * @export
 */
export const ScopesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 添加应用授权作用域
         * @param {string} cid 
         * @param {Array<number>} sid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addClientScopes: async (cid: string, sid: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling addClientScopes.');
            }
            // verify required parameter 'sid' is not null or undefined
            if (sid === null || sid === undefined) {
                throw new RequiredError('sid','Required parameter sid was null or undefined when calling addClientScopes.');
            }
            const localVarPath = `/v1/clients/{cid}/scopes`
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (sid) {
                localVarQueryParameter['sid'] = sid;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 添加应用授权作用域
         * @param {number} uid 
         * @param {string} cid 
         * @param {Array<number>} sid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserClientScopes: async (uid: number, cid: string, sid: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling addUserClientScopes.');
            }
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling addUserClientScopes.');
            }
            // verify required parameter 'sid' is not null or undefined
            if (sid === null || sid === undefined) {
                throw new RequiredError('sid','Required parameter sid was null or undefined when calling addUserClientScopes.');
            }
            const localVarPath = `/v1/users/{uid}/clients/{cid}/scopes`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (sid) {
                localVarQueryParameter['sid'] = sid;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 WRITE_SCOPE 权限。
         * @summary 删除授权作用域
         * @param {Array<number>} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScopes: async (id: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteScopes.');
            }
            const localVarPath = `/v1/scopes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 READ_CLIENT 权限。
         * @summary 获取应用授权作用域
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientScopes: async (cid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling getClientScopes.');
            }
            const localVarPath = `/v1/clients/{cid}/scopes`
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 READ_CLIENT 权限。
         * @summary 获取授权作用域
         * @param {Array<number>} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScopes: async (id?: Array<number>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/scopes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
         * @summary 获取应用授权作用域
         * @param {number} uid 
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserClientScopes: async (uid: number, cid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling getUserClientScopes.');
            }
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling getUserClientScopes.');
            }
            const localVarPath = `/v1/users/{uid}/clients/{cid}/scopes`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 删除应用授权作用域
         * @param {string} cid 
         * @param {Array<number>} sid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeClientScopes: async (cid: string, sid: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling removeClientScopes.');
            }
            // verify required parameter 'sid' is not null or undefined
            if (sid === null || sid === undefined) {
                throw new RequiredError('sid','Required parameter sid was null or undefined when calling removeClientScopes.');
            }
            const localVarPath = `/v1/clients/{cid}/scopes`
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (sid) {
                localVarQueryParameter['sid'] = sid;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 删除应用授权作用域
         * @param {number} uid 
         * @param {string} cid 
         * @param {Array<number>} sid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserClientScopes: async (uid: number, cid: string, sid: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling removeUserClientScopes.');
            }
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling removeUserClientScopes.');
            }
            // verify required parameter 'sid' is not null or undefined
            if (sid === null || sid === undefined) {
                throw new RequiredError('sid','Required parameter sid was null or undefined when calling removeUserClientScopes.');
            }
            const localVarPath = `/v1/users/{uid}/clients/{cid}/scopes`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (sid) {
                localVarQueryParameter['sid'] = sid;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 WRITE_SCOPE 权限。
         * @summary 修改或添加授权作用域
         * @param {Array<Scope>} scope 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setScopes: async (scope: Array<Scope>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling setScopes.');
            }
            const localVarPath = `/v1/scopes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof scope !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(scope !== undefined ? scope : {})
                : (scope || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScopesApi - functional programming interface
 * @export
 */
export const ScopesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 添加应用授权作用域
         * @param {string} cid 
         * @param {Array<number>} sid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addClientScopes(cid: string, sid: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ScopesApiAxiosParamCreator(configuration).addClientScopes(cid, sid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 添加应用授权作用域
         * @param {number} uid 
         * @param {string} cid 
         * @param {Array<number>} sid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserClientScopes(uid: number, cid: string, sid: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ScopesApiAxiosParamCreator(configuration).addUserClientScopes(uid, cid, sid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 WRITE_SCOPE 权限。
         * @summary 删除授权作用域
         * @param {Array<number>} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScopes(id: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ScopesApiAxiosParamCreator(configuration).deleteScopes(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 READ_CLIENT 权限。
         * @summary 获取应用授权作用域
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientScopes(cid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Scope>>> {
            const localVarAxiosArgs = await ScopesApiAxiosParamCreator(configuration).getClientScopes(cid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 READ_CLIENT 权限。
         * @summary 获取授权作用域
         * @param {Array<number>} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScopes(id?: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Scope>>> {
            const localVarAxiosArgs = await ScopesApiAxiosParamCreator(configuration).getScopes(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
         * @summary 获取应用授权作用域
         * @param {number} uid 
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserClientScopes(uid: number, cid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Scope>>> {
            const localVarAxiosArgs = await ScopesApiAxiosParamCreator(configuration).getUserClientScopes(uid, cid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 删除应用授权作用域
         * @param {string} cid 
         * @param {Array<number>} sid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeClientScopes(cid: string, sid: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ScopesApiAxiosParamCreator(configuration).removeClientScopes(cid, sid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 删除应用授权作用域
         * @param {number} uid 
         * @param {string} cid 
         * @param {Array<number>} sid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserClientScopes(uid: number, cid: string, sid: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ScopesApiAxiosParamCreator(configuration).removeUserClientScopes(uid, cid, sid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 WRITE_SCOPE 权限。
         * @summary 修改或添加授权作用域
         * @param {Array<Scope>} scope 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setScopes(scope: Array<Scope>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ScopesApiAxiosParamCreator(configuration).setScopes(scope, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ScopesApi - factory interface
 * @export
 */
export const ScopesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 添加应用授权作用域
         * @param {string} cid 
         * @param {Array<number>} sid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addClientScopes(cid: string, sid: Array<number>, options?: any): AxiosPromise<void> {
            return ScopesApiFp(configuration).addClientScopes(cid, sid, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 添加应用授权作用域
         * @param {number} uid 
         * @param {string} cid 
         * @param {Array<number>} sid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserClientScopes(uid: number, cid: string, sid: Array<number>, options?: any): AxiosPromise<void> {
            return ScopesApiFp(configuration).addUserClientScopes(uid, cid, sid, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 WRITE_SCOPE 权限。
         * @summary 删除授权作用域
         * @param {Array<number>} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScopes(id: Array<number>, options?: any): AxiosPromise<void> {
            return ScopesApiFp(configuration).deleteScopes(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 READ_CLIENT 权限。
         * @summary 获取应用授权作用域
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientScopes(cid: string, options?: any): AxiosPromise<Array<Scope>> {
            return ScopesApiFp(configuration).getClientScopes(cid, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 READ_CLIENT 权限。
         * @summary 获取授权作用域
         * @param {Array<number>} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScopes(id?: Array<number>, options?: any): AxiosPromise<Array<Scope>> {
            return ScopesApiFp(configuration).getScopes(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
         * @summary 获取应用授权作用域
         * @param {number} uid 
         * @param {string} cid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserClientScopes(uid: number, cid: string, options?: any): AxiosPromise<Array<Scope>> {
            return ScopesApiFp(configuration).getUserClientScopes(uid, cid, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 WRITE_CLIENT 权限。
         * @summary 删除应用授权作用域
         * @param {string} cid 
         * @param {Array<number>} sid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeClientScopes(cid: string, sid: Array<number>, options?: any): AxiosPromise<void> {
            return ScopesApiFp(configuration).removeClientScopes(cid, sid, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
         * @summary 删除应用授权作用域
         * @param {number} uid 
         * @param {string} cid 
         * @param {Array<number>} sid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserClientScopes(uid: number, cid: string, sid: Array<number>, options?: any): AxiosPromise<void> {
            return ScopesApiFp(configuration).removeUserClientScopes(uid, cid, sid, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 WRITE_SCOPE 权限。
         * @summary 修改或添加授权作用域
         * @param {Array<Scope>} scope 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setScopes(scope: Array<Scope>, options?: any): AxiosPromise<void> {
            return ScopesApiFp(configuration).setScopes(scope, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScopesApi - object-oriented interface
 * @export
 * @class ScopesApi
 * @extends {BaseAPI}
 */
export class ScopesApi extends BaseAPI {
    /**
     * 应用和用户需要 WRITE_CLIENT 权限。
     * @summary 添加应用授权作用域
     * @param {string} cid 
     * @param {Array<number>} sid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScopesApi
     */
    public addClientScopes(cid: string, sid: Array<number>, options?: any) {
        return ScopesApiFp(this.configuration).addClientScopes(cid, sid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
     * @summary 添加应用授权作用域
     * @param {number} uid 
     * @param {string} cid 
     * @param {Array<number>} sid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScopesApi
     */
    public addUserClientScopes(uid: number, cid: string, sid: Array<number>, options?: any) {
        return ScopesApiFp(this.configuration).addUserClientScopes(uid, cid, sid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 WRITE_SCOPE 权限。
     * @summary 删除授权作用域
     * @param {Array<number>} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScopesApi
     */
    public deleteScopes(id: Array<number>, options?: any) {
        return ScopesApiFp(this.configuration).deleteScopes(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 READ_CLIENT 权限。
     * @summary 获取应用授权作用域
     * @param {string} cid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScopesApi
     */
    public getClientScopes(cid: string, options?: any) {
        return ScopesApiFp(this.configuration).getClientScopes(cid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 READ_CLIENT 权限。
     * @summary 获取授权作用域
     * @param {Array<number>} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScopesApi
     */
    public getScopes(id?: Array<number>, options?: any) {
        return ScopesApiFp(this.configuration).getScopes(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户（uid 为当前用户除外）需要 READ_CLIENT 权限。
     * @summary 获取应用授权作用域
     * @param {number} uid 
     * @param {string} cid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScopesApi
     */
    public getUserClientScopes(uid: number, cid: string, options?: any) {
        return ScopesApiFp(this.configuration).getUserClientScopes(uid, cid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 WRITE_CLIENT 权限。
     * @summary 删除应用授权作用域
     * @param {string} cid 
     * @param {Array<number>} sid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScopesApi
     */
    public removeClientScopes(cid: string, sid: Array<number>, options?: any) {
        return ScopesApiFp(this.configuration).removeClientScopes(cid, sid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户（uid 为当前用户除外）需要 WRITE_CLIENT 权限。
     * @summary 删除应用授权作用域
     * @param {number} uid 
     * @param {string} cid 
     * @param {Array<number>} sid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScopesApi
     */
    public removeUserClientScopes(uid: number, cid: string, sid: Array<number>, options?: any) {
        return ScopesApiFp(this.configuration).removeUserClientScopes(uid, cid, sid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 WRITE_SCOPE 权限。
     * @summary 修改或添加授权作用域
     * @param {Array<Scope>} scope 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScopesApi
     */
    public setScopes(scope: Array<Scope>, options?: any) {
        return ScopesApiFp(this.configuration).setScopes(scope, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TokenApi - axios parameter creator
 * @export
 */
export const TokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 检查令牌有效性
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkOAuthToken: async (token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling checkOAuthToken.');
            }
            const localVarPath = `/v1/token/validity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientCredentials required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 检查令牌有效性
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkOAuthToken1: async (token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling checkOAuthToken1.');
            }
            const localVarPath = `/v1/token/validity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientCredentials required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 删除令牌
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 颁发 OAuth2 令牌
         * @param {string} [code] 
         * @param {string} [grantType] 
         * @param {string} [redirectUri] 
         * @param {string} [username] 
         * @param {string} [password] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantOAuthToken: async (code?: string, grantType?: string, redirectUri?: string, username?: string, password?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/oauth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientCredentials required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 颁发默认令牌
         * @param {string} username 
         * @param {string} password 
         * @param {string} gRecaptchaResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantToken: async (username: string, password: string, gRecaptchaResponse: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling grantToken.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling grantToken.');
            }
            // verify required parameter 'gRecaptchaResponse' is not null or undefined
            if (gRecaptchaResponse === null || gRecaptchaResponse === undefined) {
                throw new RequiredError('gRecaptchaResponse','Required parameter gRecaptchaResponse was null or undefined when calling grantToken.');
            }
            const localVarPath = `/v1/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            if (gRecaptchaResponse !== undefined) {
                localVarQueryParameter['g-recaptcha-response'] = gRecaptchaResponse;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenApi - functional programming interface
 * @export
 */
export const TokenApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 检查令牌有效性
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkOAuthToken(token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await TokenApiAxiosParamCreator(configuration).checkOAuthToken(token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary 检查令牌有效性
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkOAuthToken1(token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await TokenApiAxiosParamCreator(configuration).checkOAuthToken1(token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary 删除令牌
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteToken(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TokenApiAxiosParamCreator(configuration).deleteToken(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary 颁发 OAuth2 令牌
         * @param {string} [code] 
         * @param {string} [grantType] 
         * @param {string} [redirectUri] 
         * @param {string} [username] 
         * @param {string} [password] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async grantOAuthToken(code?: string, grantType?: string, redirectUri?: string, username?: string, password?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuth2AccessToken>> {
            const localVarAxiosArgs = await TokenApiAxiosParamCreator(configuration).grantOAuthToken(code, grantType, redirectUri, username, password, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary 颁发默认令牌
         * @param {string} username 
         * @param {string} password 
         * @param {string} gRecaptchaResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async grantToken(username: string, password: string, gRecaptchaResponse: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuth2AccessToken>> {
            const localVarAxiosArgs = await TokenApiAxiosParamCreator(configuration).grantToken(username, password, gRecaptchaResponse, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TokenApi - factory interface
 * @export
 */
export const TokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary 检查令牌有效性
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkOAuthToken(token: string, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return TokenApiFp(configuration).checkOAuthToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 检查令牌有效性
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkOAuthToken1(token: string, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return TokenApiFp(configuration).checkOAuthToken1(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 删除令牌
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken(options?: any): AxiosPromise<void> {
            return TokenApiFp(configuration).deleteToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 颁发 OAuth2 令牌
         * @param {string} [code] 
         * @param {string} [grantType] 
         * @param {string} [redirectUri] 
         * @param {string} [username] 
         * @param {string} [password] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantOAuthToken(code?: string, grantType?: string, redirectUri?: string, username?: string, password?: string, options?: any): AxiosPromise<OAuth2AccessToken> {
            return TokenApiFp(configuration).grantOAuthToken(code, grantType, redirectUri, username, password, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 颁发默认令牌
         * @param {string} username 
         * @param {string} password 
         * @param {string} gRecaptchaResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantToken(username: string, password: string, gRecaptchaResponse: string, options?: any): AxiosPromise<OAuth2AccessToken> {
            return TokenApiFp(configuration).grantToken(username, password, gRecaptchaResponse, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokenApi - object-oriented interface
 * @export
 * @class TokenApi
 * @extends {BaseAPI}
 */
export class TokenApi extends BaseAPI {
    /**
     * 
     * @summary 检查令牌有效性
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public checkOAuthToken(token: string, options?: any) {
        return TokenApiFp(this.configuration).checkOAuthToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 检查令牌有效性
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public checkOAuthToken1(token: string, options?: any) {
        return TokenApiFp(this.configuration).checkOAuthToken1(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 删除令牌
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public deleteToken(options?: any) {
        return TokenApiFp(this.configuration).deleteToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 颁发 OAuth2 令牌
     * @param {string} [code] 
     * @param {string} [grantType] 
     * @param {string} [redirectUri] 
     * @param {string} [username] 
     * @param {string} [password] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public grantOAuthToken(code?: string, grantType?: string, redirectUri?: string, username?: string, password?: string, options?: any) {
        return TokenApiFp(this.configuration).grantOAuthToken(code, grantType, redirectUri, username, password, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 颁发默认令牌
     * @param {string} username 
     * @param {string} password 
     * @param {string} gRecaptchaResponse 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public grantToken(username: string, password: string, gRecaptchaResponse: string, options?: any) {
        return TokenApiFp(this.configuration).grantToken(username, password, gRecaptchaResponse, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 应用需要拥有 read:user 授权。
         * @summary 获取当前 Token 的用户信息
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 检查邮箱是否存在
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isEmailExists: async (email: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling isEmailExists.');
            }
            const localVarPath = `/v1/email/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 检查用户名是否存在
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isUsernameExists: async (username: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling isUsernameExists.');
            }
            const localVarPath = `/v1/username/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 用户注册（通过邮箱验证码）
         * @param {string} username 
         * @param {string} password 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (username: string, password: string, code: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling register.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling register.');
            }
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling register.');
            }
            const localVarPath = `/v1/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用需要 WRITE_USER_EMAIL 权限。
         * @summary 通过密码更改邮箱
         * @param {string} password 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetEmail: async (password: string, code: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling resetEmail.');
            }
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling resetEmail.');
            }
            const localVarPath = `/v1/user/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用需要 WRITE_USER_PASSWORD 权限。
         * @summary 通过原密码更改用户密码
         * @param {string} oldPassword 
         * @param {string} newPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (oldPassword: string, newPassword: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'oldPassword' is not null or undefined
            if (oldPassword === null || oldPassword === undefined) {
                throw new RequiredError('oldPassword','Required parameter oldPassword was null or undefined when calling resetPassword.');
            }
            // verify required parameter 'newPassword' is not null or undefined
            if (newPassword === null || newPassword === undefined) {
                throw new RequiredError('newPassword','Required parameter newPassword was null or undefined when calling resetPassword.');
            }
            const localVarPath = `/v1/user/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (oldPassword !== undefined) {
                localVarQueryParameter['oldPassword'] = oldPassword;
            }

            if (newPassword !== undefined) {
                localVarQueryParameter['newPassword'] = newPassword;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 邮箱重置密码
         * @param {string} password 
         * @param {string} code 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordWithEmail: async (password: string, code: string, body?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling resetPasswordWithEmail.');
            }
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling resetPasswordWithEmail.');
            }
            const localVarPath = `/v1/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 应用需要拥有 read:user 授权。
         * @summary 获取当前 Token 的用户信息
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokenUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getTokenUser(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary 检查邮箱是否存在
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isEmailExists(email: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).isEmailExists(email, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary 检查用户名是否存在
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isUsernameExists(username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).isUsernameExists(username, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary 用户注册（通过邮箱验证码）
         * @param {string} username 
         * @param {string} password 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(username: string, password: string, code: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).register(username, password, code, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用需要 WRITE_USER_EMAIL 权限。
         * @summary 通过密码更改邮箱
         * @param {string} password 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetEmail(password: string, code: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).resetEmail(password, code, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用需要 WRITE_USER_PASSWORD 权限。
         * @summary 通过原密码更改用户密码
         * @param {string} oldPassword 
         * @param {string} newPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(oldPassword: string, newPassword: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).resetPassword(oldPassword, newPassword, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary 邮箱重置密码
         * @param {string} password 
         * @param {string} code 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPasswordWithEmail(password: string, code: string, body?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).resetPasswordWithEmail(password, code, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 应用需要拥有 read:user 授权。
         * @summary 获取当前 Token 的用户信息
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenUser(options?: any): AxiosPromise<User> {
            return UserApiFp(configuration).getTokenUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 检查邮箱是否存在
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isEmailExists(email: string, options?: any): AxiosPromise<boolean> {
            return UserApiFp(configuration).isEmailExists(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 检查用户名是否存在
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isUsernameExists(username: string, options?: any): AxiosPromise<boolean> {
            return UserApiFp(configuration).isUsernameExists(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 用户注册（通过邮箱验证码）
         * @param {string} username 
         * @param {string} password 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(username: string, password: string, code: string, options?: any): AxiosPromise<User> {
            return UserApiFp(configuration).register(username, password, code, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用需要 WRITE_USER_EMAIL 权限。
         * @summary 通过密码更改邮箱
         * @param {string} password 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetEmail(password: string, code: string, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).resetEmail(password, code, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用需要 WRITE_USER_PASSWORD 权限。
         * @summary 通过原密码更改用户密码
         * @param {string} oldPassword 
         * @param {string} newPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(oldPassword: string, newPassword: string, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).resetPassword(oldPassword, newPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 邮箱重置密码
         * @param {string} password 
         * @param {string} code 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordWithEmail(password: string, code: string, body?: string, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).resetPasswordWithEmail(password, code, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 应用需要拥有 read:user 授权。
     * @summary 获取当前 Token 的用户信息
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getTokenUser(options?: any) {
        return UserApiFp(this.configuration).getTokenUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 检查邮箱是否存在
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public isEmailExists(email: string, options?: any) {
        return UserApiFp(this.configuration).isEmailExists(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 检查用户名是否存在
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public isUsernameExists(username: string, options?: any) {
        return UserApiFp(this.configuration).isUsernameExists(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 用户注册（通过邮箱验证码）
     * @param {string} username 
     * @param {string} password 
     * @param {string} code 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public register(username: string, password: string, code: string, options?: any) {
        return UserApiFp(this.configuration).register(username, password, code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用需要 WRITE_USER_EMAIL 权限。
     * @summary 通过密码更改邮箱
     * @param {string} password 
     * @param {string} code 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public resetEmail(password: string, code: string, options?: any) {
        return UserApiFp(this.configuration).resetEmail(password, code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用需要 WRITE_USER_PASSWORD 权限。
     * @summary 通过原密码更改用户密码
     * @param {string} oldPassword 
     * @param {string} newPassword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public resetPassword(oldPassword: string, newPassword: string, options?: any) {
        return UserApiFp(this.configuration).resetPassword(oldPassword, newPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 邮箱重置密码
     * @param {string} password 
     * @param {string} code 
     * @param {string} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public resetPasswordWithEmail(password: string, code: string, body?: string, options?: any) {
        return UserApiFp(this.configuration).resetPasswordWithEmail(password, code, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 应用和用户需要 CREATE_USER 权限。
         * @summary 创建用户（用户名和邮箱不可重复）
         * @param {string} username 
         * @param {string} password 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (username: string, password: string, email: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling createUser.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling createUser.');
            }
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling createUser.');
            }
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需要 DELETE_USER 权限。
         * @summary 删除用户（永久删除）
         * @param {number} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (uid: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/v1/users/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 获取用户的公开信息。如果应用与用户拥有 READ_USER 权限，则获取完整信息。
         * @summary 获取用户信息
         * @param {number} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (uid: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling getUser.');
            }
            const localVarPath = `/v1/users/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 获取用户头像
         * @param {number} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAvatar: async (uid: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling getUserAvatar.');
            }
            const localVarPath = `/v1/users/{uid}/avatar`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 查询或者列出用户（取决于有无关键字(q)或者用户ID(uid)），获取公开信息。若应用和用户拥有 READ_USER 权限，则获取完整信息。
         * @summary 查找用户
         * @param {Array<number>} [uid] 
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {Array<string>} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (uid?: Array<number>, q?: string, offset?: number, limit?: number, order?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (uid) {
                localVarQueryParameter['uid'] = uid;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (order) {
                localVarQueryParameter['order'] = order;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户（修改自身信息除外）需要拥有 WRITE_USER 权限。
         * @summary 更新用户头像
         * @param {number} uid 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserAvatar: async (uid: number, body: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling updateUserAvatar.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateUserAvatar.');
            }
            const localVarPath = `/v1/users/{uid}/avatar`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'image/_*';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需拥有 WRITE_USER_EMAIL 权限。
         * @summary 更新用户邮箱
         * @param {number} uid 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserEmail: async (uid: number, code: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling updateUserEmail.');
            }
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling updateUserEmail.');
            }
            const localVarPath = `/v1/users/{uid}/email`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 封禁或解封用户。应用和用户需拥有 LOCK_USER 权限。
         * @summary 设置用户封禁或解封
         * @param {number} uid 
         * @param {boolean} enabled 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserEnabled: async (uid: number, enabled: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling updateUserEnabled.');
            }
            // verify required parameter 'enabled' is not null or undefined
            if (enabled === null || enabled === undefined) {
                throw new RequiredError('enabled','Required parameter enabled was null or undefined when calling updateUserEnabled.');
            }
            const localVarPath = `/v1/users/{uid}/ban`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 设置用户账号过期日期。设置为 NULL 则无过期时间。应用和用户需拥有 LOCK_USER 权限。
         * @summary 设置用户解锁日期
         * @param {number} uid 
         * @param {string} expiredAt 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserExpiredAt: async (uid: number, expiredAt: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling updateUserExpiredAt.');
            }
            // verify required parameter 'expiredAt' is not null or undefined
            if (expiredAt === null || expiredAt === undefined) {
                throw new RequiredError('expiredAt','Required parameter expiredAt was null or undefined when calling updateUserExpiredAt.');
            }
            const localVarPath = `/v1/users/{uid}/expired-at`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (expiredAt !== undefined) {
                localVarQueryParameter['expiredAt'] = (expiredAt as any instanceof Date) ?
                    (expiredAt as any).toISOString() :
                    expiredAt;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户（修改自身信息除外）需要拥有 WRITE_USER 权限。
         * @summary 更新用户性别
         * @param {number} uid 
         * @param {number} gender 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserGender: async (uid: number, gender: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling updateUserGender.');
            }
            // verify required parameter 'gender' is not null or undefined
            if (gender === null || gender === undefined) {
                throw new RequiredError('gender','Required parameter gender was null or undefined when calling updateUserGender.');
            }
            const localVarPath = `/v1/users/{uid}/gender`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (gender !== undefined) {
                localVarQueryParameter['gender'] = gender;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户（修改自身信息除外）需要拥有 WRITE_USER 权限。
         * @summary 更新用户昵称
         * @param {number} uid 
         * @param {string} nickname 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNickname: async (uid: number, nickname: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling updateUserNickname.');
            }
            // verify required parameter 'nickname' is not null or undefined
            if (nickname === null || nickname === undefined) {
                throw new RequiredError('nickname','Required parameter nickname was null or undefined when calling updateUserNickname.');
            }
            const localVarPath = `/v1/users/{uid}/nickname`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (nickname !== undefined) {
                localVarQueryParameter['nickname'] = nickname;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 应用和用户需拥有 WRITE_USER_PASSWORD 权限。
         * @summary 更新用户密码
         * @param {number} uid 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword: async (uid: number, password: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling updateUserPassword.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling updateUserPassword.');
            }
            const localVarPath = `/v1/users/{uid}/password`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 设置用户账号的解锁日期，在此日期日前账号不能使用。设置为 NULL 则不锁定。应用和用户需拥有 LOCK_USER 权限。
         * @summary 设置用户解锁日期
         * @param {number} uid 
         * @param {string} unlockAt 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserUnlockAt: async (uid: number, unlockAt: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling updateUserUnlockAt.');
            }
            // verify required parameter 'unlockAt' is not null or undefined
            if (unlockAt === null || unlockAt === undefined) {
                throw new RequiredError('unlockAt','Required parameter unlockAt was null or undefined when calling updateUserUnlockAt.');
            }
            const localVarPath = `/v1/users/{uid}/unlock-at`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (unlockAt !== undefined) {
                localVarQueryParameter['unlockAt'] = (unlockAt as any instanceof Date) ?
                    (unlockAt as any).toISOString() :
                    unlockAt;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 应用和用户需要 CREATE_USER 权限。
         * @summary 创建用户（用户名和邮箱不可重复）
         * @param {string} username 
         * @param {string} password 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(username: string, password: string, email: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).createUser(username, password, email, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需要 DELETE_USER 权限。
         * @summary 删除用户（永久删除）
         * @param {number} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(uid: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).deleteUser(uid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 获取用户的公开信息。如果应用与用户拥有 READ_USER 权限，则获取完整信息。
         * @summary 获取用户信息
         * @param {number} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(uid: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).getUser(uid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary 获取用户头像
         * @param {number} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAvatar(uid: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).getUserAvatar(uid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 查询或者列出用户（取决于有无关键字(q)或者用户ID(uid)），获取公开信息。若应用和用户拥有 READ_USER 权限，则获取完整信息。
         * @summary 查找用户
         * @param {Array<number>} [uid] 
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {Array<string>} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(uid?: Array<number>, q?: string, offset?: number, limit?: number, order?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultsUser>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).getUsers(uid, q, offset, limit, order, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户（修改自身信息除外）需要拥有 WRITE_USER 权限。
         * @summary 更新用户头像
         * @param {number} uid 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserAvatar(uid: number, body: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).updateUserAvatar(uid, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需拥有 WRITE_USER_EMAIL 权限。
         * @summary 更新用户邮箱
         * @param {number} uid 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserEmail(uid: number, code: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).updateUserEmail(uid, code, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 封禁或解封用户。应用和用户需拥有 LOCK_USER 权限。
         * @summary 设置用户封禁或解封
         * @param {number} uid 
         * @param {boolean} enabled 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserEnabled(uid: number, enabled: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).updateUserEnabled(uid, enabled, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 设置用户账号过期日期。设置为 NULL 则无过期时间。应用和用户需拥有 LOCK_USER 权限。
         * @summary 设置用户解锁日期
         * @param {number} uid 
         * @param {string} expiredAt 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserExpiredAt(uid: number, expiredAt: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).updateUserExpiredAt(uid, expiredAt, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户（修改自身信息除外）需要拥有 WRITE_USER 权限。
         * @summary 更新用户性别
         * @param {number} uid 
         * @param {number} gender 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserGender(uid: number, gender: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).updateUserGender(uid, gender, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户（修改自身信息除外）需要拥有 WRITE_USER 权限。
         * @summary 更新用户昵称
         * @param {number} uid 
         * @param {string} nickname 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserNickname(uid: number, nickname: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).updateUserNickname(uid, nickname, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 应用和用户需拥有 WRITE_USER_PASSWORD 权限。
         * @summary 更新用户密码
         * @param {number} uid 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPassword(uid: number, password: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).updateUserPassword(uid, password, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 设置用户账号的解锁日期，在此日期日前账号不能使用。设置为 NULL 则不锁定。应用和用户需拥有 LOCK_USER 权限。
         * @summary 设置用户解锁日期
         * @param {number} uid 
         * @param {string} unlockAt 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserUnlockAt(uid: number, unlockAt: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).updateUserUnlockAt(uid, unlockAt, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 应用和用户需要 CREATE_USER 权限。
         * @summary 创建用户（用户名和邮箱不可重复）
         * @param {string} username 
         * @param {string} password 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(username: string, password: string, email: string, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).createUser(username, password, email, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需要 DELETE_USER 权限。
         * @summary 删除用户（永久删除）
         * @param {number} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(uid: number, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).deleteUser(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 获取用户的公开信息。如果应用与用户拥有 READ_USER 权限，则获取完整信息。
         * @summary 获取用户信息
         * @param {number} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(uid: number, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).getUser(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 获取用户头像
         * @param {number} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAvatar(uid: number, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).getUserAvatar(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 查询或者列出用户（取决于有无关键字(q)或者用户ID(uid)），获取公开信息。若应用和用户拥有 READ_USER 权限，则获取完整信息。
         * @summary 查找用户
         * @param {Array<number>} [uid] 
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {Array<string>} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(uid?: Array<number>, q?: string, offset?: number, limit?: number, order?: Array<string>, options?: any): AxiosPromise<QueryResultsUser> {
            return UsersApiFp(configuration).getUsers(uid, q, offset, limit, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户（修改自身信息除外）需要拥有 WRITE_USER 权限。
         * @summary 更新用户头像
         * @param {number} uid 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserAvatar(uid: number, body: any, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).updateUserAvatar(uid, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需拥有 WRITE_USER_EMAIL 权限。
         * @summary 更新用户邮箱
         * @param {number} uid 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserEmail(uid: number, code: string, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).updateUserEmail(uid, code, options).then((request) => request(axios, basePath));
        },
        /**
         * 封禁或解封用户。应用和用户需拥有 LOCK_USER 权限。
         * @summary 设置用户封禁或解封
         * @param {number} uid 
         * @param {boolean} enabled 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserEnabled(uid: number, enabled: boolean, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).updateUserEnabled(uid, enabled, options).then((request) => request(axios, basePath));
        },
        /**
         * 设置用户账号过期日期。设置为 NULL 则无过期时间。应用和用户需拥有 LOCK_USER 权限。
         * @summary 设置用户解锁日期
         * @param {number} uid 
         * @param {string} expiredAt 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserExpiredAt(uid: number, expiredAt: string, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).updateUserExpiredAt(uid, expiredAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户（修改自身信息除外）需要拥有 WRITE_USER 权限。
         * @summary 更新用户性别
         * @param {number} uid 
         * @param {number} gender 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserGender(uid: number, gender: number, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).updateUserGender(uid, gender, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户（修改自身信息除外）需要拥有 WRITE_USER 权限。
         * @summary 更新用户昵称
         * @param {number} uid 
         * @param {string} nickname 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNickname(uid: number, nickname: string, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).updateUserNickname(uid, nickname, options).then((request) => request(axios, basePath));
        },
        /**
         * 应用和用户需拥有 WRITE_USER_PASSWORD 权限。
         * @summary 更新用户密码
         * @param {number} uid 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword(uid: number, password: string, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).updateUserPassword(uid, password, options).then((request) => request(axios, basePath));
        },
        /**
         * 设置用户账号的解锁日期，在此日期日前账号不能使用。设置为 NULL 则不锁定。应用和用户需拥有 LOCK_USER 权限。
         * @summary 设置用户解锁日期
         * @param {number} uid 
         * @param {string} unlockAt 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserUnlockAt(uid: number, unlockAt: string, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).updateUserUnlockAt(uid, unlockAt, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 应用和用户需要 CREATE_USER 权限。
     * @summary 创建用户（用户名和邮箱不可重复）
     * @param {string} username 
     * @param {string} password 
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(username: string, password: string, email: string, options?: any) {
        return UsersApiFp(this.configuration).createUser(username, password, email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需要 DELETE_USER 权限。
     * @summary 删除用户（永久删除）
     * @param {number} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(uid: number, options?: any) {
        return UsersApiFp(this.configuration).deleteUser(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 获取用户的公开信息。如果应用与用户拥有 READ_USER 权限，则获取完整信息。
     * @summary 获取用户信息
     * @param {number} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(uid: number, options?: any) {
        return UsersApiFp(this.configuration).getUser(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 获取用户头像
     * @param {number} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserAvatar(uid: number, options?: any) {
        return UsersApiFp(this.configuration).getUserAvatar(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 查询或者列出用户（取决于有无关键字(q)或者用户ID(uid)），获取公开信息。若应用和用户拥有 READ_USER 权限，则获取完整信息。
     * @summary 查找用户
     * @param {Array<number>} [uid] 
     * @param {string} [q] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {Array<string>} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(uid?: Array<number>, q?: string, offset?: number, limit?: number, order?: Array<string>, options?: any) {
        return UsersApiFp(this.configuration).getUsers(uid, q, offset, limit, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户（修改自身信息除外）需要拥有 WRITE_USER 权限。
     * @summary 更新用户头像
     * @param {number} uid 
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserAvatar(uid: number, body: any, options?: any) {
        return UsersApiFp(this.configuration).updateUserAvatar(uid, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需拥有 WRITE_USER_EMAIL 权限。
     * @summary 更新用户邮箱
     * @param {number} uid 
     * @param {string} code 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserEmail(uid: number, code: string, options?: any) {
        return UsersApiFp(this.configuration).updateUserEmail(uid, code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 封禁或解封用户。应用和用户需拥有 LOCK_USER 权限。
     * @summary 设置用户封禁或解封
     * @param {number} uid 
     * @param {boolean} enabled 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserEnabled(uid: number, enabled: boolean, options?: any) {
        return UsersApiFp(this.configuration).updateUserEnabled(uid, enabled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 设置用户账号过期日期。设置为 NULL 则无过期时间。应用和用户需拥有 LOCK_USER 权限。
     * @summary 设置用户解锁日期
     * @param {number} uid 
     * @param {string} expiredAt 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserExpiredAt(uid: number, expiredAt: string, options?: any) {
        return UsersApiFp(this.configuration).updateUserExpiredAt(uid, expiredAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户（修改自身信息除外）需要拥有 WRITE_USER 权限。
     * @summary 更新用户性别
     * @param {number} uid 
     * @param {number} gender 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserGender(uid: number, gender: number, options?: any) {
        return UsersApiFp(this.configuration).updateUserGender(uid, gender, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户（修改自身信息除外）需要拥有 WRITE_USER 权限。
     * @summary 更新用户昵称
     * @param {number} uid 
     * @param {string} nickname 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserNickname(uid: number, nickname: string, options?: any) {
        return UsersApiFp(this.configuration).updateUserNickname(uid, nickname, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 应用和用户需拥有 WRITE_USER_PASSWORD 权限。
     * @summary 更新用户密码
     * @param {number} uid 
     * @param {string} password 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserPassword(uid: number, password: string, options?: any) {
        return UsersApiFp(this.configuration).updateUserPassword(uid, password, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 设置用户账号的解锁日期，在此日期日前账号不能使用。设置为 NULL 则不锁定。应用和用户需拥有 LOCK_USER 权限。
     * @summary 设置用户解锁日期
     * @param {number} uid 
     * @param {string} unlockAt 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserUnlockAt(uid: number, unlockAt: string, options?: any) {
        return UsersApiFp(this.configuration).updateUserUnlockAt(uid, unlockAt, options).then((request) => request(this.axios, this.basePath));
    }
}


